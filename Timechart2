#!/usr/bin/env python3
"""
FIXED ECU Timing Diagram Generator for Excel
Removes the extra line on top issue
"""

import openpyxl
from openpyxl import Workbook
from openpyxl.styles import PatternFill, Border, Side, Alignment, Font
from openpyxl.utils import get_column_letter

class SimpleTimingDiagram:
    """Fixed timing diagram generator without extra top line"""
    
    def __init__(self):
        self.wb = Workbook()
        self.ws = self.wb.active
        self.ws.title = "Timing"
        
        # Border styles for signals
        self.thin = Side(style='thin', color='000000')
        self.medium = Side(style='medium', color='000000')
        self.thick = Side(style='thick', color='000000')
        self.dotted = Side(style='dotted', color='808080')
        
        # State colors
        self.colors = {
            'OFF': 'FF6B6B',      # Red
            'INIT': 'FFD93D',     # Yellow  
            'RUN': '6BCF7F',      # Green
            'SLEEP': 'E8E8E8',    # Light gray
            'WAKE': 'FFE66D',     # Light yellow
            'POST1': '95E1D3',    # Light cyan
            'POST2': 'F38181',    # Light red
            'POSTRUN1': '95E1D3', # Light cyan
            'POSTRUN2': 'F38181', # Light red
            'LATCH': '4ECDC4',    # Cyan
            'POWERLATCH': '4ECDC4', # Cyan
            'START': 'FFD93D',    # Yellow
        }
        
        self.current_row = 5  # Start signals at row 5
        self.time_units = 50  # Total time units to show
        self.first_signal_row = 5
        self.last_signal_row = 5
        
    def setup_basic_grid(self, title="ECU Timing Diagram"):
        """Basic setup with proper MEASUREMENT header"""
        
        # Column widths
        self.ws.column_dimensions['B'].width = 25  # Signal names
        for i in range(3, 53):  # 50 time columns
            self.ws.column_dimensions[get_column_letter(i)].width = 2.5
            
        # MEASUREMENT header in row 2 (not row 1)
        self.ws.merge_cells('B2:AZ2')
        self.ws['B2'] = 'MEASUREMENT'
        self.ws['B2'].font = Font(size=12, bold=True)
        self.ws['B2'].alignment = Alignment(horizontal='center', vertical='center')
        
        # Time header in row 3
        for i in range(0, self.time_units, 5):
            cell = self.ws.cell(row=3, column=3+i, value=f"{i*20}ms")
            cell.font = Font(size=9, italic=True)
            
        # Add vertical dotted grid lines
        for i in range(0, self.time_units):
            if i % 5 == 0:  # Major grid every 5 units
                for row in range(4, 50):
                    cell = self.ws.cell(row=row, column=3+i)
                    existing = cell.border
                    cell.border = Border(
                        left=self.dotted,
                        right=existing.right if existing else None,
                        top=existing.top if existing else None,
                        bottom=existing.bottom if existing else None
                    )
        
        # Leave row 4 empty as spacer
        self.current_row = 5
        self.first_signal_row = 5
    
    def add(self, signal_name, pattern):
        """Add signal with proper border handling"""
        row = self.current_row
        self.current_row += 1
        self.last_signal_row = row
        
        # Add signal name
        self.ws.cell(row=row, column=2, value=signal_name)
        self.ws.cell(row=row, column=2).font = Font(size=10, bold=True)
        
        # Handle different pattern types
        if ' ' in pattern:
            # State pattern (words separated by spaces)
            self._add_states(row, pattern.split())
        else:
            # Digital pattern with border-based representation
            self._add_digital_with_borders(row, pattern)
            
        # Set row height
        self.ws.row_dimensions[row].height = 20
    
    def _add_digital_with_borders(self, row, pattern):
        """Add digital signal using borders for transitions"""
        
        for i, char in enumerate(pattern):
            if i >= self.time_units:
                break
                
            cell = self.ws.cell(row=row, column=3+i)
            
            # Get previous value
            prev_val = pattern[i-1] if i > 0 else '0'
            
            # Determine borders based on signal level and transitions
            if char == '1':
                if prev_val == '0':
                    # Rising edge: left + top
                    cell.border = Border(left=self.thin, top=self.thin)
                else:
                    # High level: just top
                    cell.border = Border(top=self.thin)
            elif char == '0':
                if prev_val == '1':
                    # Falling edge: apply right border to previous cell
                    if i > 0:
                        prev_cell = self.ws.cell(row=row, column=3+i-1)
                        prev_border = prev_cell.border
                        prev_cell.border = Border(
                            left=prev_border.left if prev_border else None,
                            right=self.thin,
                            top=prev_border.top if prev_border else None,
                            bottom=prev_border.bottom if prev_border else None
                        )
                    # Current cell gets bottom border
                    cell.border = Border(bottom=self.thin)
                else:
                    # Low level: just bottom
                    cell.border = Border(bottom=self.thin)
            elif char == '-':
                # Don't care - dotted line
                cell.border = Border(top=self.dotted, bottom=self.dotted)
            elif char == 'X':
                # Undefined - box
                cell.border = Border(
                    left=self.dotted, right=self.dotted,
                    top=self.dotted, bottom=self.dotted
                )
    
    def _add_states(self, row, states):
        """Add state machine signal from list of states"""
        current_state = states[0]
        start_col = 0
        
        for i, state in enumerate(states + ['END']):
            if state != current_state or i == len(states):
                # State changed, draw the previous state
                end_col = i - 1
                
                if end_col >= start_col:
                    # Merge cells for this state
                    if end_col > start_col:
                        self.ws.merge_cells(
                            start_row=row, start_column=3+start_col,
                            end_row=row, end_column=3+end_col
                        )
                    
                    # Set state text and color
                    cell = self.ws.cell(row=row, column=3+start_col)
                    cell.value = current_state
                    cell.alignment = Alignment(horizontal='center', vertical='center')
                    cell.font = Font(size=9, bold=True)
                    
                    # Apply color
                    color = self.colors.get(current_state.upper(), 'FFFFFF')
                    cell.fill = PatternFill(start_color=color, end_color=color, fill_type='solid')
                    
                    # Add borders around state box
                    for col in range(3+start_col, 3+end_col+1):
                        c = self.ws.cell(row=row, column=col)
                        c.border = Border(
                            left=self.thin if col == 3+start_col else None,
                            right=self.thin if col == 3+end_col else None,
                            top=self.thin,
                            bottom=self.thin
                        )
                
                # Update for next state
                current_state = state
                start_col = i
    
    def add_box_signal(self, signal_name, start, end, label=""):
        """Add a box-style signal"""
        row = self.current_row
        self.current_row += 1
        self.last_signal_row = row
        
        # Add signal name
        self.ws.cell(row=row, column=2, value=signal_name)
        self.ws.cell(row=row, column=2).font = Font(size=10, bold=True)
        
        # Draw box
        for i in range(start, end + 1):
            cell = self.ws.cell(row=row, column=3+i)
            
            cell.border = Border(
                left=self.thin if i == start else None,
                right=self.thin if i == end else None,
                top=self.thin,
                bottom=self.thin
            )
        
        # Add label if provided
        if label:
            mid = (start + end) // 2
            cell = self.ws.cell(row=row, column=3+mid, value=label)
            cell.font = Font(size=9, italic=True)
            cell.alignment = Alignment(horizontal='center', vertical='center')
        
        self.ws.row_dimensions[row].height = 20
    
    def space(self):
        """Add empty row for spacing"""
        self.current_row += 1
    
    def section(self, title):
        """Add section header"""
        row = self.current_row
        self.current_row += 1
        
        self.ws.merge_cells(f'B{row}:D{row}')
        cell = self.ws.cell(row=row, column=2, value=title)
        cell.font = Font(size=11, bold=True)
        cell.fill = PatternFill(start_color='D9D9D9', end_color='D9D9D9', fill_type='solid')
        cell.border = Border(
            left=self.medium,
            right=self.medium,
            top=self.medium,
            bottom=self.medium
        )
    
    def timing_mark(self, start_time, end_time, label):
        """Add timing annotation"""
        row = self.current_row
        self.current_row += 1
        self.last_signal_row = row
        
        # Add label at midpoint
        mid = (start_time + end_time) // 2
        cell = self.ws.cell(row=row, column=3+mid, value=label)
        cell.font = Font(size=9, italic=True, color='FF0000')
        cell.alignment = Alignment(horizontal='center')
        
        # Draw line with end markers
        for i in range(start_time, end_time + 1):
            cell = self.ws.cell(row=row, column=3+i)
            if i == start_time:
                cell.border = Border(left=self.thin, bottom=Side(style='thin', color='FF0000'))
            elif i == end_time:
                cell.border = Border(right=self.thin, bottom=Side(style='thin', color='FF0000'))
            else:
                cell.border = Border(bottom=Side(style='thin', color='FF0000'))
    
    def add_main_border(self):
        """Add thick border around entire diagram ONLY"""
        # Start from row 2 (MEASUREMENT header) to last signal row
        start_row = 2
        end_row = self.last_signal_row + 1
        start_col = 2  # Column B
        end_col = 52   # Column AZ
        
        # Apply borders to all cells in the range
        for row in range(start_row, end_row + 1):
            for col in range(start_col, end_col + 1):
                cell = self.ws.cell(row=row, column=col)
                existing = cell.border
                
                # Determine which borders to apply
                left = self.thick if col == start_col else (existing.left if existing else None)
                right = self.thick if col == end_col else (existing.right if existing else None)
                top = self.thick if row == start_row else (existing.top if existing else None)
                bottom = self.thick if row == end_row else (existing.bottom if existing else None)
                
                # Only update if we're on an edge
                if col == start_col or col == end_col or row == start_row or row == end_row:
                    cell.border = Border(left=left, right=right, top=top, bottom=bottom)
    
    def save(self, filename="timing.xlsx"):
        """Save the file"""
        # Add main border
        self.add_main_border()
        
        # Remove gridlines for cleaner look
        self.ws.sheet_view.showGridLines = False
        
        # Save
        self.wb.save(filename)
        print(f"✓ Saved: {filename}")


def create_timing_diagram():
    """Create timing diagram with exact format from image"""
    
    # Create diagram
    t = SimpleTimingDiagram()
    t.setup_basic_grid()
    
    # State signal like in image
    t.add("5Y5 State", "INIT INIT RUN RUN RUN POWERLATCH POWERLATCH POSTRUN1 POSTRUN1 POSTRUN2 OFF OFF OFF")
    
    # Digital signals with transitions
    t.add("Power", "00111111111111111111111111111111111111000")
    t.add("Ignition", "00011111111111111111111111111111111110000")
    t.space()
    
    # Box signal with "Don't Care" label
    t.add_box_signal("Sequence mode", 5, 35, "Don't Care")
    t.space()
    
    # Another box signal
    t.add_box_signal("CAN/LIN Wakeup", 8, 30)
    
    # Timing mark
    t.timing_mark(10, 15, "200 ms")
    t.space()
    
    # More signals
    t.add("Brake", "00000000001111100000000000000000000000000")
    t.add("CAN Active", "00000001111111111111111111111111100000000")
    
    # Save
    t.save("fixed_timing_diagram.xlsx")
    
    return t


def create_from_text_file():
    """Create from text file input"""
    t = SimpleTimingDiagram()
    t.setup_basic_grid("My Timing Diagram")
    
    try:
        with open('signals.txt', 'r') as f:
            for line in f:
                line = line.strip()
                if not line or line.startswith('#'):
                    continue
                    
                if line.startswith('SECTION:'):
                    t.section(line.split(':', 1)[1])
                elif line.startswith('SPACE'):
                    t.space()
                elif line.startswith('BOX:'):
                    parts = line.split(':')
                    name = parts[1]
                    start = int(parts[2])
                    end = int(parts[3])
                    label = parts[4] if len(parts) > 4 else ""
                    t.add_box_signal(name, start, end, label)
                elif line.startswith('TIMING:'):
                    parts = line.split(':')[1].split(',')
                    t.timing_mark(int(parts[0]), int(parts[1]), parts[2])
                elif ':' in line:
                    name, pattern = line.split(':', 1)
                    t.add(name, pattern)
        
        t.save("timing_from_file.xlsx")
        print("✓ Timing diagram created from file")
        
    except FileNotFoundError:
        print("Creating example signals.txt...")
        with open('signals.txt', 'w') as f:
            f.write("""# ECU Timing Signals
# Format: SignalName:Pattern

5Y5_State:OFF OFF OFF INIT INIT RUN RUN RUN POWERLATCH POSTRUN1 POSTRUN2 OFF
Battery:00000111111111111111111111111111111111111000000
Ignition:00000001111111111111111111111111111111100000000
SPACE

BOX:Sequence_Mode:5:35:Don't Care
BOX:CAN_LIN_Wakeup:8:30:
TIMING:10,15,200 ms
SPACE

CAN_TX:00000000110011001100110011001100110011000000000
CAN_RX:00000000001100110011001100110011001100000000000
Brake:00000000000011111000000000000000000000000000000
""")
        print("✓ Created signals.txt - Edit and run again!")


if __name__ == "__main__":
    print("\n" + "="*60)
    print("FIXED ECU TIMING DIAGRAM GENERATOR")
    print("="*60)
    print("No extra line on top - Fixed border handling")
    print("="*60)
    
    # Create the fixed timing diagram
    print("\n1. Creating timing diagram...")
    create_timing_diagram()
    
    print("\n2. Creating from text file...")
    create_from_text_file()
    
    print("\n" + "="*60)
    print("✓ COMPLETE! Check your Excel files:")
    print("  - fixed_timing_diagram.xlsx (no extra top line)")
    print("  - timing_from_file.xlsx")
    print("\nThe extra line issue has been fixed!")
    print("="*60)