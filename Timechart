#!/usr/bin/env python3
"""
Advanced Multi-Format ECU Timing Diagram Generator
Creates timing charts AND data tables from simple text files
"""

import openpyxl
from openpyxl import Workbook
from openpyxl.styles import PatternFill, Border, Side, Alignment, Font
from openpyxl.utils import get_column_letter
import os

class AdvancedTimingGenerator:
    """Advanced timing diagram generator with chart and table modes"""

    def __init__(self):
        self.wb = Workbook()
        self.ws = None
        self.sections = []
        self.current_section_idx = -1
        
        # Configuration
        self.config = {
            'mode': 'chart',  # 'chart', 'table', or 'both'
            'time_unit_ms': 50,  # milliseconds per column
            'time_columns': 50,  # number of time columns
            'table_layout': 'horizontal',  # 'horizontal' or 'vertical'
            'signal_groups': {}  # Organized signal groups
        }

        # Border styles
        self.thin = Side(style='thin', color='000000')
        self.medium = Side(style='medium', color='000000')
        self.thick = Side(style='thick', color='000000')
        self.dotted = Side(style='dotted', color='808080')

        # State colors (fully configurable)
        self.colors = {
            'OFF': 'FF6B6B', 'IDLE': 'E8E8E8', 'INIT': 'FFD93D', 
            'RUN': '6BCF7F', 'ACTIVE': '00FF00', 'SLEEP': 'C0C0C0',
            'WAKE': 'FFE66D', 'POST1': '95E1D3', 'POST2': 'F38181',
            'POSTRUN1': '95E1D3', 'POSTRUN2': 'F38181',
            'LATCH': '4ECDC4', 'POWERLATCH': '4ECDC4',
            'ERROR': 'FF0000', 'WARNING': 'FFA500',
            'INACTIVE': 'C0C0C0', 'READY': '90EE90',
            'TEST': 'DDA0DD', 'PASS': '00FF00', 'FAIL': 'FF0000',
            'LOW': 'E8E8E8', 'HIGH': '00FF00',
            'Z': 'FFA500', 'X': 'FF0000'
        }

    def process_file(self, filename):
        """Process timing diagram configuration file"""
        if not os.path.exists(filename):
            self.create_example_file(filename)
            print(f"âœ“ Created example file: {filename}")
            print("  Edit it and run again!")
            return False

        with open(filename, 'r') as f:
            lines = f.readlines()

        current_group = None
        
        for line in lines:
            line = line.strip()
            if not line or line.startswith('#'):
                continue

            # Configuration commands
            if line.startswith('CONFIG:'):
                self.process_config(line[7:].strip())
            elif line.startswith('COLOR:'):
                self.process_color(line[6:].strip())
            elif line.startswith('SECTION:'):
                self.start_new_section(line[8:].strip())
            elif line.startswith('GROUP:'):
                current_group = line[6:].strip()
            elif line.startswith('SUBSECTION:'):
                self.add_subsection(line[11:].strip())
            elif line.startswith('SIGNAL:'):
                self.add_signal(line[7:].strip(), current_group)
            elif line.startswith('BOX:'):
                self.add_box_signal(line[4:].strip(), current_group)
            elif line.startswith('TIMING:'):
                self.add_timing(line[7:].strip())
            elif line.startswith('SPACE'):
                self.add_space()
            elif ':' in line and not line.startswith('//'):
                parts = line.split(':', 1)
                self.add_signal(f"{parts[0].strip()}:{parts[1].strip()}", current_group)

        return True

    def process_config(self, config_line):
        """Process configuration command
        Format: CONFIG:key=value"""
        if '=' not in config_line:
            return
        
        key, value = config_line.split('=', 1)
        key = key.strip().lower()
        value = value.strip()

        if key == 'mode':
            self.config['mode'] = value.lower()
        elif key == 'time_unit_ms':
            self.config['time_unit_ms'] = int(value)
        elif key == 'time_columns':
            self.config['time_columns'] = int(value)
        elif key == 'table_layout':
            self.config['table_layout'] = value.lower()

    def process_color(self, color_line):
        """Process color definition
        Format: COLOR:STATE_NAME=HEXCOLOR"""
        if '=' not in color_line:
            return
        
        state, color = color_line.split('=', 1)
        self.colors[state.strip().upper()] = color.strip().replace('#', '')

    def start_new_section(self, section_info):
        """Start a new main section
        Format: SECTION:name[,sheet_name][,mode]"""
        parts = section_info.split(',')
        section_name = parts[0].strip()
        sheet_name = parts[1].strip() if len(parts) > 1 else section_name[:31]
        section_mode = parts[2].strip().lower() if len(parts) > 2 else self.config['mode']

        # Create new sheet
        if self.current_section_idx == -1:
            self.ws = self.wb.active
            self.ws.title = sheet_name
        else:
            self.ws = self.wb.create_sheet(sheet_name)

        self.current_section_idx += 1

        section = {
            'name': section_name,
            'sheet': self.ws,
            'mode': section_mode,
            'current_row': 1,
            'signals': [],  # Store signal data for table generation
            'groups': {}
        }
        self.sections.append(section)

        # Setup based on mode
        if section_mode in ['chart', 'both']:
            self.setup_chart_section(section)
        
        if section_mode in ['table', 'both']:
            # Table will be created after chart or in separate area
            pass

    def setup_chart_section(self, section):
        """Setup chart visualization section"""
        self.ws = section['sheet']
        
        # Title
        self.ws.merge_cells('B2:AZ2')
        self.ws['B2'] = section['name'].upper()
        self.ws['B2'].font = Font(size=14, bold=True)
        self.ws['B2'].alignment = Alignment(horizontal='center', vertical='center')
        self.ws.row_dimensions[2].height = 25

        # Column widths
        self.ws.column_dimensions['A'].width = 3
        self.ws.column_dimensions['B'].width = 25
        for i in range(3, 3 + self.config['time_columns']):
            self.ws.column_dimensions[get_column_letter(i)].width = 2.5

        # Time header
        section['current_row'] = 4
        time_unit = self.config['time_unit_ms']
        
        for i in range(0, self.config['time_columns']):
            time_ms = i * time_unit
            if i % 5 == 0:  # Show every 5th column
                cell = self.ws.cell(row=4, column=3+i, value=f"{time_ms}ms")
                cell.font = Font(size=8, bold=True)
                cell.alignment = Alignment(horizontal='center')

        # Grid lines
        for i in range(0, self.config['time_columns']):
            if i % 5 == 0:
                for row in range(5, 100):
                    cell = self.ws.cell(row=row, column=3+i)
                    cell.border = Border(left=self.dotted)

        section['current_row'] = 5
        section['first_signal_row'] = 5

    def add_subsection(self, title):
        """Add subsection header"""
        if self.current_section_idx < 0:
            return

        section = self.sections[self.current_section_idx]
        row = section['current_row']
        section['current_row'] += 1

        if section['mode'] in ['chart', 'both']:
            self.ws.merge_cells(f'B{row}:E{row}')
            cell = self.ws.cell(row=row, column=2, value=title)
            cell.font = Font(size=10, bold=True, italic=True)
            cell.fill = PatternFill(start_color='D9D9D9', end_color='D9D9D9', fill_type='solid')
            cell.border = Border(left=self.medium, right=self.medium, 
                               top=self.medium, bottom=self.medium)
            self.ws.row_dimensions[row].height = 18

    def add_signal(self, signal_info, group=None):
        """Add a signal
        Format: name:pattern[:type]"""
        if self.current_section_idx < 0:
            return

        parts = signal_info.split(':')
        if len(parts) < 2:
            return

        name = parts[0].strip()
        pattern = parts[1].strip()
        signal_type = parts[2].strip() if len(parts) > 2 else 'auto'

        section = self.sections[self.current_section_idx]
        
        # Store signal data
        signal_data = {
            'name': name,
            'pattern': pattern,
            'type': signal_type,
            'group': group,
            'values': self.parse_pattern(pattern)
        }
        section['signals'].append(signal_data)

        # Draw chart if needed
        if section['mode'] in ['chart', 'both']:
            row = section['current_row']
            section['current_row'] += 1
            section['last_signal_row'] = row

            # Signal name
            self.ws.cell(row=row, column=2, value=name)
            self.ws.cell(row=row, column=2).font = Font(size=9, bold=True)
            self.ws.cell(row=row, column=2).alignment = Alignment(vertical='center')

            # Determine pattern type
            if ' ' in pattern or signal_type == 'state':
                self._add_states(row, pattern.split() if ' ' in pattern else [pattern])
            elif all(c in '01-XZ' for c in pattern) or signal_type == 'digital':
                self._add_digital(row, pattern)
            elif pattern.replace('.', '').replace('-', '').isdigit() or signal_type == 'analog':
                self._add_analog(row, pattern.split())
            else:
                self._add_states(row, pattern.split())

            self.ws.row_dimensions[row].height = 22

    def add_box_signal(self, box_info, group=None):
        """Add box signal
        Format: name:start:end[:label][:color]"""
        if self.current_section_idx < 0:
            return

        parts = box_info.split(':')
        if len(parts) < 3:
            return

        name = parts[0].strip()
        start = int(parts[1].strip())
        end = int(parts[2].strip())
        label = parts[3].strip() if len(parts) > 3 else ""
        color = parts[4].strip() if len(parts) > 4 else 'CCCCCC'

        section = self.sections[self.current_section_idx]
        
        # Store signal data
        signal_data = {
            'name': name,
            'type': 'box',
            'start': start,
            'end': end,
            'label': label,
            'group': group
        }
        section['signals'].append(signal_data)

        if section['mode'] in ['chart', 'both']:
            row = section['current_row']
            section['current_row'] += 1
            section['last_signal_row'] = row

            self.ws.cell(row=row, column=2, value=name)
            self.ws.cell(row=row, column=2).font = Font(size=9, bold=True)

            # Draw box
            for i in range(start, min(end + 1, self.config['time_columns'])):
                cell = self.ws.cell(row=row, column=3+i)
                cell.fill = PatternFill(start_color=color, end_color=color, fill_type='solid')
                cell.border = Border(
                    left=self.thin if i == start else None,
                    right=self.thin if i == end else None,
                    top=self.thin,
                    bottom=self.thin
                )

            if label and end - start > 2:
                mid = (start + end) // 2
                cell = self.ws.cell(row=row, column=3+mid, value=label)
                cell.font = Font(size=8, bold=True)
                cell.alignment = Alignment(horizontal='center', vertical='center')

            self.ws.row_dimensions[row].height = 22

    def add_timing(self, timing_info):
        """Add timing annotation
        Format: start:end:label[:color]"""
        if self.current_section_idx < 0:
            return

        parts = timing_info.split(':')
        if len(parts) < 3:
            return

        start = int(parts[0].strip())
        end = int(parts[1].strip())
        label = parts[2].strip()
        color = parts[3].strip() if len(parts) > 3 else 'FF0000'

        section = self.sections[self.current_section_idx]
        
        if section['mode'] in ['chart', 'both']:
            row = section['current_row']
            section['current_row'] += 1

            mid = (start + end) // 2
            cell = self.ws.cell(row=row, column=3+mid, value=label)
            cell.font = Font(size=9, italic=True, bold=True, color=color)
            cell.alignment = Alignment(horizontal='center')

            for i in range(start, min(end + 1, self.config['time_columns'])):
                cell = self.ws.cell(row=row, column=3+i)
                if i == start or i == end:
                    cell.border = Border(
                        left=self.thin if i == start else None,
                        right=self.thin if i == end else None,
                        top=Side(style='thin', color=color)
                    )
                else:
                    cell.border = Border(top=Side(style='thin', color=color))

            self.ws.row_dimensions[row].height = 18

    def add_space(self):
        """Add empty row"""
        if self.current_section_idx >= 0:
            self.sections[self.current_section_idx]['current_row'] += 1

    def parse_pattern(self, pattern):
        """Parse pattern into values array"""
        if ' ' in pattern:
            return pattern.split()
        else:
            return list(pattern)

    def _add_digital(self, row, pattern):
        """Add digital signal with proper transitions"""
        prev_val = '0'

        for i, char in enumerate(pattern[:self.config['time_columns']]):
            cell = self.ws.cell(row=row, column=3+i)

            if char in ['0', '1', 'Z', 'X']:
                color = self.colors.get(char.upper(), 'FFFFFF')
                
                if i > 0:
                    prev_val = pattern[i-1] if i > 0 else '0'

                # Transitions
                if prev_val != char:
                    if char in ['1', 'Z', 'X']:
                        cell.border = Border(left=self.thin, top=self.thin)
                        cell.fill = PatternFill(start_color=color, end_color=color, fill_type='solid')
                    else:
                        if i > 0:
                            prev_cell = self.ws.cell(row=row, column=3+i-1)
                            prev_border = prev_cell.border
                            prev_cell.border = Border(
                                left=prev_border.left,
                                right=self.thin,
                                top=prev_border.top,
                                bottom=prev_border.bottom
                            )
                        cell.border = Border(bottom=self.thin)
                else:
                    if char in ['1', 'Z', 'X']:
                        cell.border = Border(top=self.thin)
                        cell.fill = PatternFill(start_color=color, end_color=color, fill_type='solid')
                    else:
                        cell.border = Border(bottom=self.thin)
            elif char == '-':
                cell.border = Border(top=self.dotted, bottom=self.dotted)

    def _add_states(self, row, states):
        """Add state signal"""
        max_cols = self.config['time_columns']
        current_state = states[0] if states else ''
        start_col = 0

        # Extend states to fill all columns if needed
        extended_states = []
        for state in states:
            extended_states.append(state)
        
        # Fill remaining columns with last state
        while len(extended_states) < max_cols:
            extended_states.append(extended_states[-1] if extended_states else 'IDLE')

        for i, state in enumerate(extended_states[:max_cols] + ['END']):
            if state != current_state or i == len(extended_states[:max_cols]):
                end_col = i - 1

                if end_col >= start_col and start_col < max_cols:
                    end_col = min(end_col, max_cols - 1)
                    
                    if end_col > start_col:
                        self.ws.merge_cells(
                            start_row=row, start_column=3+start_col,
                            end_row=row, end_column=3+end_col
                        )

                    cell = self.ws.cell(row=row, column=3+start_col)
                    cell.value = current_state
                    cell.alignment = Alignment(horizontal='center', vertical='center')
                    cell.font = Font(size=8, bold=True)

                    color = self.colors.get(current_state.upper(), 'FFFFFF')
                    cell.fill = PatternFill(start_color=color, end_color=color, fill_type='solid')

                    for col in range(3+start_col, 3+end_col+1):
                        c = self.ws.cell(row=row, column=col)
                        c.border = Border(
                            left=self.medium if col == 3+start_col else None,
                            right=self.medium if col == 3+end_col else None,
                            top=self.thin,
                            bottom=self.thin
                        )

                current_state = state
                start_col = i

    def _add_analog(self, row, values):
        """Add analog signal representation"""
        max_cols = self.config['time_columns']
        
        for i, val in enumerate(values[:max_cols]):
            cell = self.ws.cell(row=row, column=3+i, value=val)
            cell.font = Font(size=8)
            cell.alignment = Alignment(horizontal='center', vertical='center')
            cell.border = Border(
                left=self.thin if i == 0 else None,
                right=self.thin if i == len(values)-1 else None,
                top=self.thin,
                bottom=self.thin
            )

    def create_data_table(self, section):
        """Create data table view of signals"""
        ws = section['sheet']
        signals = section['signals']
        
        # Find starting position (after chart if mode is 'both')
        if section['mode'] == 'both':
            start_row = section['current_row'] + 3
        else:
            start_row = 2

        # Table title
        ws.merge_cells(f'B{start_row}:E{start_row}')
        cell = ws.cell(row=start_row, column=2, value=f"{section['name']} - DATA TABLE")
        cell.font = Font(size=12, bold=True)
        cell.fill = PatternFill(start_color='4472C4', end_color='4472C4', fill_type='solid')
        cell.font = Font(size=12, bold=True, color='FFFFFF')
        cell.alignment = Alignment(horizontal='center', vertical='center')
        ws.row_dimensions[start_row].height = 25

        current_row = start_row + 1

        # Headers
        header_row = current_row
        current_row += 1

        ws.cell(row=header_row, column=2, value="Signal Name")
        ws.cell(row=header_row, column=3, value="Type")
        
        # Time column headers
        time_unit = self.config['time_unit_ms']
        for i in range(min(15, self.config['time_columns'])):  # Show up to 15 columns
            time_ms = i * time_unit
            cell = ws.cell(row=header_row, column=4+i, value=f"{time_ms}ms")
            cell.alignment = Alignment(horizontal='center')

        # Style headers
        for col in range(2, 20):
            cell = ws.cell(row=header_row, column=col)
            cell.font = Font(bold=True, size=9)
            cell.fill = PatternFill(start_color='D9D9D9', end_color='D9D9D9', fill_type='solid')
            cell.border = Border(
                left=self.thin, right=self.thin,
                top=self.medium, bottom=self.medium
            )

        # Data rows
        for signal in signals:
            if signal.get('type') == 'box':
                continue  # Skip box signals in table

            ws.cell(row=current_row, column=2, value=signal['name'])
            
            # Determine type
            pattern = signal['pattern']
            if ' ' in pattern:
                sig_type = "State Machine"
            elif all(c in '01-XZ' for c in pattern):
                sig_type = "Digital"
            else:
                sig_type = "Analog"
            
            ws.cell(row=current_row, column=3, value=sig_type)

            # Values
            values = signal['values']
            for i, val in enumerate(values[:min(15, self.config['time_columns'])]):
                cell = ws.cell(row=current_row, column=4+i, value=val)
                cell.alignment = Alignment(horizontal='center')
                
                # Color coding
                if val.upper() in self.colors:
                    color = self.colors[val.upper()]
                    cell.fill = PatternFill(start_color=color, end_color=color, fill_type='solid')

            # Borders
            for col in range(2, 20):
                cell = ws.cell(row=current_row, column=col)
                cell.border = Border(
                    left=self.thin, right=self.thin,
                    top=self.thin, bottom=self.thin
                )

            current_row += 1

    def finalize(self):
        """Finalize all sections"""
        for section in self.sections:
            self.ws = section['sheet']

            # Create data table if needed
            if section['mode'] in ['table', 'both']:
                self.create_data_table(section)

            # Add borders to chart area
            if section['mode'] in ['chart', 'both'] and 'last_signal_row' in section:
                start_row = 2
                end_row = section.get('last_signal_row', section['current_row'])
                start_col = 2
                end_col = 2 + self.config['time_columns']

                for row in range(start_row, end_row + 1):
                    for col in range(start_col, end_col + 1):
                        if row == start_row or row == end_row or col == start_col or col == end_col:
                            cell = self.ws.cell(row=row, column=col)
                            existing = cell.border
                            cell.border = Border(
                                left=self.thick if col == start_col else (existing.left if existing else None),
                                right=self.thick if col == end_col else (existing.right if existing else None),
                                top=self.thick if row == start_row else (existing.top if existing else None),
                                bottom=self.thick if row == end_row else (existing.bottom if existing else None)
                            )

            self.ws.sheet_view.showGridLines = False

    def save(self, filename):
        """Save the workbook"""
        self.finalize()
        self.wb.save(filename)
        print(f"âœ“ Saved: {filename}")

    def create_example_file(self, filename):
        """Create comprehensive example file"""
        example_content = """# ADVANCED ECU TIMING DIAGRAM CONFIGURATION
# ==========================================
# 
# CONFIGURATION COMMANDS:
# -----------------------
# CONFIG:mode=chart|table|both          - Output mode
# CONFIG:time_unit_ms=50                - Time per column in ms
# CONFIG:time_columns=50                - Number of time columns
# CONFIG:table_layout=horizontal        - Table layout
# COLOR:STATE_NAME=HEXCOLOR             - Custom state colors
#
# SECTION COMMANDS:
# -----------------
# SECTION:name[,sheet_name][,mode]      - Start new section
# GROUP:group_name                      - Start signal group
# SUBSECTION:title                      - Add subsection header
# SIGNAL:name:pattern[:type]            - Add signal (digital/state/analog)
# BOX:name:start:end[:label][:color]    - Add box signal
# TIMING:start:end:label[:color]        - Add timing mark
# SPACE                                 - Add empty row
#
# SIGNAL TYPES:
# -------------
# Digital: 0=low, 1=high, Z=high-impedance, X=undefined, -=don't care
# State: Space-separated state names (OFF INIT RUN ERROR)
# Analog: Space-separated numeric values
#
# ==========================================

# Global Configuration
CONFIG:mode=both
CONFIG:time_unit_ms=50
CONFIG:time_columns=50

# Custom Colors
COLOR:MEASUREMENT=4CAF50
COLOR:DIAGNOSIS=FF9800
COLOR:STARTUP=2196F3

# ============================================================
# MAIN SYSTEM SECTION (Both Chart and Table)
# ============================================================
SECTION:MAIN_SYSTEM,System,both

SUBSECTION:State Machines
STATE:IDLE IDLE INIT INIT ACTIVE ACTIVE ACTIVE ACTIVE ACTIVE WARNING ERROR ERROR IDLE IDLE

SUBSECTION:Power Management
Battery_Enable:00000111111111111111111111111111111111111000000
Ignition:00001111111111111111111111111111111111111100000000
5V_Rail:00000011111111111111111111111111111111111000000000
3V3_Rail:00000000111111111111111111111111111111110000000000
SPACE

SUBSECTION:Digital Signals
SPI_MOSI:01010101010101010101010101010101010101010101010
I2C_SDA:ZZ001100110011001100110011001100110011ZZ000000
Enable:00000000001111111111111111111111111111100000000000
Error_Flag:00000000000000000000000000000011111110000000000
Clock:01010101010101010101010101010101010101010101010
SPACE

SUBSECTION:PWM Signals  
BOX:PWM_Output:5:10:0%:E8E8E8
BOX:PWM_Output:10:15:25%:FFD93D
BOX:PWM_Output:15:20:50%:FFA500
BOX:PWM_Output:20:25:75%:FF6B00
BOX:PWM_Output:25:35:100%:FF0000
BOX:PWM_Output:35:40:75%:FF6B00
BOX:PWM_Output:40:45:25%:FFD93D
BOX:PWM_Output:45:50:0%:E8E8E8
SPACE

TIMING:5:35:Active Period:0000FF
TIMING:10:15:Ramp Up:00FF00
TIMING:35:40:Ramp Down:FF0000

# ============================================================
# COMMUNICATION SECTION (Chart Only)
# ============================================================
SECTION:COMMUNICATION,Comm,chart

SUBSECTION:CAN Bus
CAN_TX:01010101010101010101010101010101010101010101010
CAN_RX:10101010101010101010101010101010101010101010101
CAN_Error:00000000000000000011110000000000000000000000000
BOX:CAN_Message:10:20:Frame 1:4CAF50
BOX:CAN_Message:25:35:Frame 2:4CAF50
SPACE

SUBSECTION:LIN Bus
LIN_TX:00000000111111111111111111111111111111100000000
LIN_RX:00000000011111111111111111111111111111000000000
BOX:LIN_Header:8:12:Header:2196F3
BOX:LIN_Data:12:30:Data:4CAF50
SPACE

SUBSECTION:Diagnostic Signals
Diag_Request:00000000001111111111111111111111100000000000
Diag_Response:00000000000011111111111111111111000000000000
Diag_Error:00000000000000000000000001111000000000000000000

# ============================================================
# ANALOG SECTION (Table Only)
# ============================================================  
SECTION:ANALOG_SIGNALS,Analog,table

GROUP:Voltage Monitoring
Voltage_5V:0 0 0 3.3 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0 3.3 0 0
Voltage_3V3:0 0 0 0 3.3 3.3 3.3 3.3 3.3 3.3 3.3 3.3 3.3 3.3 3.3 0 0
Battery_V:12.0 12.0 12.0 12.0 14.4 14.4 14.4 14.4 14.4 14.4 14.4 14.4 12.0 12.0 12.0 12.0

GROUP:Current Monitoring  
Current_Load:0 0 2 10 25 50 100 150 120 80 40 5 0 0 0 0
Current_Charge:0 0 0 0 0 0 5 10 15 15 10 5 0 0 0 0

GROUP:Temperature
Temp_MCU:25 25 26 28 35 45 55 65 70 68 60 50 40 35 30 25
Temp_Motor:20 20 21 25 35 50 75 90 95 90 80 65 50 40 30 25

# ============================================================
# MOTOR CONTROL SECTION
# ============================================================
SECTION:MOTOR_CONTROL,Motor,both

SUBSECTION:Control Signals
Motor_Enable:00000001111111111111111111111111111111000000000
Direction_FWD:00000001111111111111111100000000000000000000000
Direction_REV:00000000000000000000000011111111111111000000000
Brake:00000000000011111100000000000000001111100000000000
SPACE

SUBSECTION:Feedback Signals
Hall_A:01010101010101010101010101010101010101010101010
Hall_B:10101010101010101010101010101010101010101010101
Hall_C:01100110011001100110011001100110011001100110011
Encoder:01234567890123456789012345678901234567890123456
SPACE

BOX:Speed_Profile:5:15:Accel:4CAF50
BOX:Speed_Profile:15:35:Constant:2196F3
BOX:Speed_Profile:35:45:Decel:FFA500

# ============================================================
# SAFETY & DIAGNOSTICS SECTION
# ============================================================
SECTION:SAFETY,Safety,both

SUBSECTION:Safety Monitors
Overvoltage:00000000000000000000000011111110000000000000000
Overcurrent:00000000000000000000000000000111111100000000000
Overtemp:00000000000000000000000000000000000011111100000
Watchdog_OK:11111111111111111111111111111111111111111111111
SPACE

SUBSECTION:Fault Handling
Fault_Detected:00000000000000000000000001111111000000000000000
Fault_Latched:00000000000000000000000001111111111111111111111
Recovery:00000000000000000000000000000000000011111100000
System_Reset:00000000000000000000000000000000000000001000000
SPACE

SUBSECTION:Status LEDs
LED_Power:IDLE IDLE OFF INIT ACTIVE ACTIVE ACTIVE ACTIVE ACTIVE ACTIVE ACTIVE ACTIVE OFF IDLE
LED_Status:OFF OFF OFF INIT READY ACTIVE ACTIVE ACTIVE ACTIVE ACTIVE ERROR ERROR OFF OFF
LED_Error:OFF OFF OFF OFF OFF OFF OFF OFF OFF OFF ERROR ERROR ERROR OFF

# ============================================================
"""
        with open(filename, 'w') as f:
            f.write(example_content)


def main():
    """Main function"""
    print("\n" + "="*70)
    print("ADVANCED TIMING DIAGRAM & DATA TABLE GENERATOR")
    print("="*70)

    config_file = "advanced_timing.txt"
    output_file = "advanced_timing_output.xlsx"

    print(f"\nProcessing: {config_file}")
    print("-" * 70)

    generator = AdvancedTimingGenerator()
    if generator.process_file(config_file):
        generator.save(output_file)
        print(f"\nâœ“ Successfully generated: {output_file}")
        print(f"\nðŸ“Š Output includes:")
        for i, section in enumerate(generator.sections, 1):
            print(f"  {i}. {section['name']} ({section['mode']} mode)")
    else:
        print(f"\nâš  Please edit {config_file} and run again")

    print("\n" + "="*70)
    print("CONFIGURATION OPTIONS:")
    print("="*70)
    print("""
CONFIG COMMANDS:
  CONFIG:mode=chart            # Chart visualization only
  CONFIG:mode=table            # Data table only  
  CONFIG:mode=both             # Both chart and table
  CONFIG:time_unit_ms=50       # Milliseconds per column
  CONFIG:time_columns=50       # Number of time columns
  
COLOR CUSTOMIZATION:
  COLOR:ACTIVE=00FF00          # Custom state colors
  
SIGNAL FORMATS:
  Digital:  0=low, 1=high, Z=high-z, X=undefined
  State:    Space-separated state names
  Analog:   Space-separated numeric values
  Box:      BOX:name:start:end:label:color
  Timing:   TIMING:start:end:label:color
    """)
    print("="*70)


if __name__ == "__main__":
    main()