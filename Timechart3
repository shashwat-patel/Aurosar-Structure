#!/usr/bin/env python3
"""
Same-Sheet Multi-Section ECU Timing Diagram Generator
Creates multiple sections on the same Excel sheet
"""

import openpyxl
from openpyxl import Workbook
from openpyxl.styles import PatternFill, Border, Side, Alignment, Font
from openpyxl.utils import get_column_letter
import os

class SameSheetTimingGenerator:
    """Timing diagram generator with multiple sections on same sheet"""
    
    def __init__(self):
        self.wb = Workbook()
        self.ws = self.wb.active
        self.ws.title = "Timing Diagram"
        
        # Track sections on same sheet
        self.sections = []
        self.current_row = 1
        self.section_spacing = 3  # Rows between sections
        
        # Border styles
        self.thin = Side(style='thin', color='000000')
        self.medium = Side(style='medium', color='000000')
        self.thick = Side(style='thick', color='000000')
        self.dotted = Side(style='dotted', color='808080')
        
        # State colors
        self.colors = {
            'OFF': 'FF6B6B',      # Red
            'INIT': 'FFD93D',     # Yellow  
            'RUN': '6BCF7F',      # Green
            'SLEEP': 'E8E8E8',    # Light gray
            'WAKE': 'FFE66D',     # Light yellow
            'POST1': '95E1D3',    # Light cyan
            'POST2': 'F38181',    # Light red
            'POSTRUN1': '95E1D3', # Light cyan
            'POSTRUN2': 'F38181', # Light red
            'LATCH': '4ECDC4',    # Cyan
            'POWERLATCH': '4ECDC4', # Cyan
            'ERROR': 'FF0000',    # Bright red
            'ACTIVE': '00FF00',   # Bright green
            'INACTIVE': 'C0C0C0', # Gray
            'READY': '90EE90',    # Light green
            'IDLE': 'F0E68C',     # Khaki
            'TEST': 'DDA0DD',     # Plum
            'PASS': '00FF00',     # Green
            'FAIL': 'FF0000',     # Red
        }
        
        self.time_units = 50
        
        # Setup column widths once
        self.ws.column_dimensions['B'].width = 25
        for i in range(3, 53):
            self.ws.column_dimensions[get_column_letter(i)].width = 2.5
    
    def process_file(self, filename):
        """Process timing diagram file"""
        if not os.path.exists(filename):
            self.create_example_file(filename)
            print(f"âœ“ Created example file: {filename}")
            print("  Edit it and run again!")
            return False
        
        with open(filename, 'r') as f:
            lines = f.readlines()
        
        current_section = None
        
        for line in lines:
            line = line.strip()
            if not line or line.startswith('#'):
                continue
            
            # Process commands
            if line.startswith('SECTION:'):
                # Start new section on same sheet
                section_name = line[8:].strip()
                current_section = self.start_new_section(section_name)
            
            elif line.startswith('NEWSECTION:'):
                # Alternative syntax for clarity
                section_name = line[11:].strip()
                current_section = self.start_new_section(section_name)
            
            elif line.startswith('SUBSECTION:'):
                if current_section:
                    self.add_subsection(current_section, line[11:].strip())
            
            elif line.startswith('SIGNAL:'):
                if current_section:
                    self.add_signal(current_section, line[7:].strip())
            
            elif line.startswith('BOX:'):
                if current_section:
                    self.add_box_signal(current_section, line[4:].strip())
            
            elif line.startswith('TIMING:'):
                if current_section:
                    self.add_timing(current_section, line[7:].strip())
            
            elif line.startswith('SPACE'):
                if current_section:
                    self.add_space(current_section)
            
            elif ':' in line and not line.startswith('//'):
                # Simple format: SignalName:Pattern
                if current_section:
                    parts = line.split(':', 1)
                    self.add_signal(current_section, f"{parts[0].strip()}:{parts[1].strip()}")
        
        # Finalize all sections
        for section in self.sections:
            self.finalize_section(section)
        
        return True
    
    def start_new_section(self, section_name):
        """Start a new section on the same sheet"""
        
        # Leave space between sections
        if self.sections:
            self.current_row += self.section_spacing
        
        section = {
            'name': section_name,
            'start_row': self.current_row,
            'header_row': self.current_row,
            'time_row': self.current_row + 1,
            'first_signal_row': self.current_row + 3,
            'current_row': self.current_row + 3,
            'last_signal_row': self.current_row + 3
        }
        
        # Add section header
        self.ws.merge_cells(f'B{section["header_row"]}:AZ{section["header_row"]}')
        header_cell = self.ws.cell(row=section['header_row'], column=2, value=section_name.upper())
        header_cell.font = Font(size=12, bold=True)
        header_cell.alignment = Alignment(horizontal='center', vertical='center')
        
        # Add time header for this section
        for i in range(0, self.time_units, 5):
            cell = self.ws.cell(row=section['time_row'], column=3+i, value=f"{i*20}ms")
            cell.font = Font(size=9, italic=True)
        
        # Add vertical grid lines for this section (will extend as signals are added)
        self.update_grid_lines(section)
        
        self.sections.append(section)
        self.current_row = section['current_row']
        
        return section
    
    def update_grid_lines(self, section):
        """Update vertical grid lines for a section"""
        for i in range(0, self.time_units):
            if i % 5 == 0:
                # Extend grid lines from time row to last signal row
                for row in range(section['time_row'] + 1, section['last_signal_row'] + 5):
                    cell = self.ws.cell(row=row, column=3+i)
                    if not cell.border or not cell.border.left:
                        cell.border = Border(left=self.dotted)
    
    def add_subsection(self, section, title):
        """Add subsection header"""
        row = section['current_row']
        section['current_row'] += 1
        section['last_signal_row'] = row
        self.current_row = section['current_row']
        
        self.ws.merge_cells(f'B{row}:D{row}')
        cell = self.ws.cell(row=row, column=2, value=title)
        cell.font = Font(size=11, bold=True)
        cell.fill = PatternFill(start_color='D9D9D9', end_color='D9D9D9', fill_type='solid')
        cell.border = Border(left=self.medium, right=self.medium, 
                           top=self.medium, bottom=self.medium)
        
        # Update grid lines
        self.update_grid_lines(section)
    
    def add_signal(self, section, signal_info):
        """Add a signal"""
        parts = signal_info.split(':', 1)
        if len(parts) != 2:
            return
        
        name = parts[0].strip()
        pattern = parts[1].strip()
        
        row = section['current_row']
        section['current_row'] += 1
        section['last_signal_row'] = row
        self.current_row = section['current_row']
        
        # Add signal name
        self.ws.cell(row=row, column=2, value=name)
        self.ws.cell(row=row, column=2).font = Font(size=10, bold=True)
        
        # Handle pattern
        if ' ' in pattern:
            self._add_states(row, pattern.split())
        else:
            self._add_digital(row, pattern)
        
        self.ws.row_dimensions[row].height = 20
        
        # Update grid lines
        self.update_grid_lines(section)
    
    def add_box_signal(self, section, box_info):
        """Add box signal"""
        parts = box_info.split(':')
        if len(parts) < 3:
            return
        
        name = parts[0].strip()
        start = int(parts[1].strip())
        end = int(parts[2].strip())
        label = parts[3].strip() if len(parts) > 3 else ""
        
        row = section['current_row']
        section['current_row'] += 1
        section['last_signal_row'] = row
        self.current_row = section['current_row']
        
        self.ws.cell(row=row, column=2, value=name)
        self.ws.cell(row=row, column=2).font = Font(size=10, bold=True)
        
        for i in range(start, end + 1):
            cell = self.ws.cell(row=row, column=3+i)
            cell.border = Border(
                left=self.thin if i == start else None,
                right=self.thin if i == end else None,
                top=self.thin,
                bottom=self.thin
            )
        
        if label:
            mid = (start + end) // 2
            cell = self.ws.cell(row=row, column=3+mid, value=label)
            cell.font = Font(size=9, italic=True)
            cell.alignment = Alignment(horizontal='center', vertical='center')
        
        self.ws.row_dimensions[row].height = 20
        self.update_grid_lines(section)
    
    def add_timing(self, section, timing_info):
        """Add timing mark"""
        parts = timing_info.split(':')
        if len(parts) != 3:
            return
        
        start = int(parts[0].strip())
        end = int(parts[1].strip())
        label = parts[2].strip()
        
        row = section['current_row']
        section['current_row'] += 1
        section['last_signal_row'] = row
        self.current_row = section['current_row']
        
        mid = (start + end) // 2
        cell = self.ws.cell(row=row, column=3+mid, value=label)
        cell.font = Font(size=9, italic=True, color='FF0000')
        cell.alignment = Alignment(horizontal='center')
        
        for i in range(start, end + 1):
            cell = self.ws.cell(row=row, column=3+i)
            if i == start:
                cell.border = Border(left=self.thin, top=self.thin)
            elif i == end:
                cell.border = Border(right=self.thin, top=self.thin)
            else:
                cell.border = Border(top=Side(style='thin', color='FF0000'))
        
        self.update_grid_lines(section)
    
    def add_space(self, section):
        """Add empty row"""
        section['current_row'] += 1
        self.current_row = section['current_row']
    
    def _add_digital(self, row, pattern):
        """Add digital signal with borders"""
        prev_val = '0'
        
        for i, char in enumerate(pattern):
            if i >= self.time_units:
                break
            
            cell = self.ws.cell(row=row, column=3+i)
            
            if char in ['0', '1']:
                if i > 0:
                    prev_val = pattern[i-1] if i > 0 else '0'
                
                if prev_val != char:
                    if char == '1':
                        cell.border = Border(left=self.thin, top=self.thin)
                    else:
                        if i > 0:
                            prev_cell = self.ws.cell(row=row, column=3+i-1)
                            prev_border = prev_cell.border
                            prev_cell.border = Border(
                                left=prev_border.left,
                                right=self.thin,
                                top=prev_border.top,
                                bottom=prev_border.bottom
                            )
                        cell.border = Border(bottom=self.thin)
                elif char == '1':
                    cell.border = Border(top=self.thin)
                else:
                    cell.border = Border(bottom=self.thin)
            elif char == '-':
                cell.border = Border(top=self.dotted)
            elif char == 'X':
                cell.border = Border(left=self.dotted, right=self.dotted,
                                   top=self.dotted, bottom=self.dotted)
    
    def _add_states(self, row, states):
        """Add state signal"""
        current_state = states[0]
        start_col = 0
        
        for i, state in enumerate(states + ['END']):
            if state != current_state or i == len(states):
                end_col = i - 1
                
                if end_col >= start_col:
                    if end_col > start_col:
                        self.ws.merge_cells(
                            start_row=row, start_column=3+start_col,
                            end_row=row, end_column=3+end_col
                        )
                    
                    cell = self.ws.cell(row=row, column=3+start_col)
                    cell.value = current_state
                    cell.alignment = Alignment(horizontal='center', vertical='center')
                    cell.font = Font(size=9, bold=True)
                    
                    color = self.colors.get(current_state.upper(), 'FFFFFF')
                    cell.fill = PatternFill(start_color=color, end_color=color, fill_type='solid')
                    
                    for col in range(3+start_col, 3+end_col+1):
                        c = self.ws.cell(row=row, column=col)
                        c.border = Border(
                            left=self.thin if col == 3+start_col else None,
                            right=self.thin if col == 3+end_col else None,
                            top=self.thin,
                            bottom=self.thin
                        )
                
                current_state = state
                start_col = i
    
    def finalize_section(self, section):
        """Add border around a section"""
        start_row = section['header_row']
        end_row = section['last_signal_row']
        start_col = 2
        end_col = 52
        
        for row in range(start_row, end_row + 1):
            for col in range(start_col, end_col + 1):
                if row == start_row or row == end_row or col == start_col or col == end_col:
                    cell = self.ws.cell(row=row, column=col)
                    existing = cell.border
                    cell.border = Border(
                        left=self.thick if col == start_col else (existing.left if existing else None),
                        right=self.thick if col == end_col else (existing.right if existing else None),
                        top=self.thick if row == start_row else (existing.top if existing else None),
                        bottom=self.thick if row == end_row else (existing.bottom if existing else None)
                    )
    
    def save(self, filename):
        """Save the workbook"""
        self.ws.sheet_view.showGridLines = False
        self.wb.save(filename)
        print(f"âœ“ Saved: {filename}")
    
    def create_example_file(self, filename):
        """Create an example input file"""
        example_content = """# Same-Sheet Multi-Section Timing Diagram
# ========================================
# All sections appear on the same sheet, stacked vertically
#
# Commands:
#   SECTION:name       - Start new section (on same sheet)
#   SUBSECTION:name    - Add subsection header
#   name:pattern       - Add signal
#   BOX:name:start:end[:label] - Box signal
#   TIMING:start:end:label     - Timing annotation
#   SPACE              - Empty row

# ============================================================
# First Section - MEASUREMENT
# ============================================================
SECTION:MEASUREMENT

SUBSECTION:Power Management
5Y5_State:OFF OFF OFF INIT INIT RUN RUN RUN POWERLATCH POSTRUN1 POSTRUN2 OFF
Battery:00000111111111111111111111111111111111111000000
Ignition:00000001111111111111111111111111111111100000000
SPACE

SUBSECTION:Communication
BOX:Sequence_Mode:5:35:Don't Care
BOX:CAN_LIN_Wakeup:8:30
TIMING:10:15:200 ms
CAN_TX:00000000110011001100110011001100110011000000000
CAN_RX:00000000001100110011001100110011001100000000000
SPACE

# ============================================================
# Second Section - OPERATION (Same Sheet, Below First)
# ============================================================
SECTION:OPERATION

SUBSECTION:Motor Control
Motor_Enable:00000001111111111111111111111111111111000000000
Motor_PWM:00000000110011001100110011001100110011000000000
Motor_Dir:00000001111111111111111100000000000000000000000
TIMING:20:30:Ramp Up
SPACE

SUBSECTION:System States
ECU_Mode:IDLE IDLE READY READY ACTIVE ACTIVE ACTIVE ACTIVE IDLE IDLE
Charging:OFF OFF OFF READY ACTIVE ACTIVE ACTIVE READY OFF OFF
SPACE

# ============================================================
# Third Section - DIAGNOSTICS (Same Sheet, Below Second)
# ============================================================
SECTION:DIAGNOSTICS

SUBSECTION:Error Detection
Error_Code:OFF OFF OFF OFF ERROR ERROR ERROR OFF OFF OFF OFF OFF
Warning:00000000000000001111111111000000000000000000000
Fault_Reset:00000000000000000000000000000001000000000000000
TIMING:15:25:Error Active

SUBSECTION:Test Mode
Test_Enable:00000000001111111111111111111111100000000000000
Test_Pattern:01010101010101010101010101010101010101010101010
Test_Result:IDLE IDLE IDLE TEST TEST PASS PASS IDLE IDLE IDLE

# ============================================================
# You can add more sections - they all stack on same sheet
# ============================================================
"""
        with open(filename, 'w') as f:
            f.write(example_content)


def main():
    """Main function"""
    print("\n" + "="*70)
    print("SAME-SHEET MULTI-SECTION TIMING DIAGRAM GENERATOR")
    print("="*70)
    print("All sections appear on the same Excel sheet, stacked vertically")
    print("="*70)
    
    # Process files
    files = [
        ("same_sheet_timing.txt", "same_sheet_output.xlsx"),
    ]
    
    for input_file, output_file in files:
        print(f"\nProcessing: {input_file}")
        print("-" * 40)
        
        generator = SameSheetTimingGenerator()
        if generator.process_file(input_file):
            generator.save(output_file)
            print(f"âœ“ Generated: {output_file}")
            print(f"  Sections: {len(generator.sections)} on same sheet")
        else:
            print(f"  Please edit {input_file} and run again")
    
    print("\n" + "="*70)
    print("ADVANTAGES OF SAME-SHEET SECTIONS:")
    print("="*70)
    print("âœ“ All sections visible at once")
    print("âœ“ Easy to compare signals across sections")
    print("âœ“ Single page for printing")
    print("âœ“ Better for documentation")
    print("âœ“ No sheet switching needed")
    print("="*70)


if __name__ == "__main__":
    main()