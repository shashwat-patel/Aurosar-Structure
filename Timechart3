#!/usr/bin/env python3
"""
Multi-Section ECU Timing Diagram Generator for Excel
Creates timing diagrams with multiple main sections like MEASUREMENT, OPERATION, etc.
"""

import openpyxl
from openpyxl import Workbook
from openpyxl.styles import PatternFill, Border, Side, Alignment, Font
from openpyxl.utils import get_column_letter

class MultiSectionTimingDiagram:
    """Timing diagram generator with multiple main sections"""
    
    def __init__(self):
        self.wb = Workbook()
        self.ws = None
        self.sections = []  # Store section info
        
        # Border styles
        self.thin = Side(style='thin', color='000000')
        self.medium = Side(style='medium', color='000000')
        self.thick = Side(style='thick', color='000000')
        self.dotted = Side(style='dotted', color='808080')
        
        # State colors
        self.colors = {
            'OFF': 'FF6B6B',      # Red
            'INIT': 'FFD93D',     # Yellow  
            'RUN': '6BCF7F',      # Green
            'SLEEP': 'E8E8E8',    # Light gray
            'WAKE': 'FFE66D',     # Light yellow
            'POST1': '95E1D3',    # Light cyan
            'POST2': 'F38181',    # Light red
            'POSTRUN1': '95E1D3', # Light cyan
            'POSTRUN2': 'F38181', # Light red
            'LATCH': '4ECDC4',    # Cyan
            'POWERLATCH': '4ECDC4', # Cyan
            'ERROR': 'FF0000',    # Bright red
            'ACTIVE': '00FF00',   # Bright green
            'INACTIVE': 'C0C0C0', # Gray
            'CHARGING': 'FFA500', # Orange
            'READY': '90EE90',    # Light green
        }
        
        self.time_units = 50  # Total time units
        
    def create_section(self, section_name, sheet_name=None):
        """Create a new main section (like MEASUREMENT, OPERATION, etc.)"""
        if sheet_name is None:
            sheet_name = section_name[:31]  # Excel sheet name limit
        
        # Create new sheet or use first one
        if self.ws is None:
            self.ws = self.wb.active
            self.ws.title = sheet_name
        else:
            self.ws = self.wb.create_sheet(sheet_name)
        
        # Store section info
        section_info = {
            'name': section_name,
            'sheet': self.ws,
            'current_row': 5,
            'first_signal_row': 5,
            'last_signal_row': 5
        }
        self.sections.append(section_info)
        
        # Setup the section
        self._setup_section_header(section_name)
        
        return section_info
    
    def _setup_section_header(self, section_name):
        """Setup header for a section"""
        # Section name in row 2
        self.ws.merge_cells('B2:AZ2')
        self.ws['B2'] = section_name.upper()
        self.ws['B2'].font = Font(size=12, bold=True)
        self.ws['B2'].alignment = Alignment(horizontal='center', vertical='center')
        
        # Column widths
        self.ws.column_dimensions['B'].width = 25
        for i in range(3, 53):
            self.ws.column_dimensions[get_column_letter(i)].width = 2.5
        
        # Time header in row 3
        for i in range(0, self.time_units, 5):
            cell = self.ws.cell(row=3, column=3+i, value=f"{i*20}ms")
            cell.font = Font(size=9, italic=True)
        
        # Vertical grid lines
        for i in range(0, self.time_units):
            if i % 5 == 0:
                for row in range(4, 50):
                    cell = self.ws.cell(row=row, column=3+i)
                    cell.border = Border(left=self.dotted)
    
    def add_signal_to_section(self, section_index, signal_name, pattern):
        """Add a signal to a specific section"""
        if section_index >= len(self.sections):
            raise ValueError(f"Section {section_index} does not exist")
        
        section = self.sections[section_index]
        self.ws = section['sheet']
        row = section['current_row']
        section['current_row'] += 1
        section['last_signal_row'] = row
        
        # Add signal name
        self.ws.cell(row=row, column=2, value=signal_name)
        self.ws.cell(row=row, column=2).font = Font(size=10, bold=True)
        
        # Handle pattern
        if ' ' in pattern:
            self._add_states(row, pattern.split())
        else:
            self._add_digital_with_borders(row, pattern)
        
        self.ws.row_dimensions[row].height = 20
    
    def _add_digital_with_borders(self, row, pattern):
        """Add digital signal using borders"""
        prev_val = '0'
        
        for i, char in enumerate(pattern):
            if i >= self.time_units:
                break
            
            cell = self.ws.cell(row=row, column=3+i)
            
            left_border = None
            right_border = None
            top_border = None
            bottom_border = None
            
            if char in ['0', '1']:
                if i > 0:
                    prev_val = pattern[i-1] if i > 0 else '0'
                
                if prev_val != char:
                    if char == '1':
                        left_border = self.thin
                        top_border = self.thin
                    else:
                        if i > 0:
                            prev_cell = self.ws.cell(row=row, column=3+i-1)
                            prev_border = prev_cell.border
                            prev_cell.border = Border(
                                left=prev_border.left,
                                right=self.thin,
                                top=prev_border.top,
                                bottom=prev_border.bottom
                            )
                        top_border = self.thin
                
                if char == '1':
                    if not top_border:
                        top_border = self.thin
                else:
                    bottom_border = self.thin
            
            elif char == '-':
                top_border = self.dotted
            elif char == 'X':
                left_border = self.dotted
                right_border = self.dotted
                top_border = self.dotted
                bottom_border = self.dotted
            
            if left_border or right_border or top_border or bottom_border:
                cell.border = Border(
                    left=left_border,
                    right=right_border,
                    top=top_border,
                    bottom=bottom_border
                )
    
    def _add_states(self, row, states):
        """Add state machine signal"""
        current_state = states[0]
        start_col = 0
        
        for i, state in enumerate(states + ['END']):
            if state != current_state or i == len(states):
                end_col = i - 1
                
                if end_col >= start_col:
                    if end_col > start_col:
                        self.ws.merge_cells(
                            start_row=row, start_column=3+start_col,
                            end_row=row, end_column=3+end_col
                        )
                    
                    cell = self.ws.cell(row=row, column=3+start_col)
                    cell.value = current_state
                    cell.alignment = Alignment(horizontal='center', vertical='center')
                    cell.font = Font(size=9, bold=True)
                    
                    color = self.colors.get(current_state.upper(), 'FFFFFF')
                    cell.fill = PatternFill(start_color=color, end_color=color, fill_type='solid')
                    
                    for col in range(3+start_col, 3+end_col+1):
                        c = self.ws.cell(row=row, column=col)
                        c.border = Border(
                            left=self.thin if col == 3+start_col else None,
                            right=self.thin if col == 3+end_col else None,
                            top=self.thin,
                            bottom=self.thin
                        )
                
                current_state = state
                start_col = i
    
    def add_box_to_section(self, section_index, signal_name, start, end, label=""):
        """Add a box signal to a section"""
        section = self.sections[section_index]
        self.ws = section['sheet']
        row = section['current_row']
        section['current_row'] += 1
        section['last_signal_row'] = row
        
        self.ws.cell(row=row, column=2, value=signal_name)
        self.ws.cell(row=row, column=2).font = Font(size=10, bold=True)
        
        for i in range(start, end + 1):
            cell = self.ws.cell(row=row, column=3+i)
            cell.border = Border(
                left=self.thin if i == start else None,
                right=self.thin if i == end else None,
                top=self.thin,
                bottom=self.thin
            )
        
        if label:
            mid = (start + end) // 2
            cell = self.ws.cell(row=row, column=3+mid, value=label)
            cell.font = Font(size=9, italic=True)
            cell.alignment = Alignment(horizontal='center', vertical='center')
        
        self.ws.row_dimensions[row].height = 20
    
    def add_subsection_to_section(self, section_index, title):
        """Add a subsection header within a section"""
        section = self.sections[section_index]
        self.ws = section['sheet']
        row = section['current_row']
        section['current_row'] += 1
        
        self.ws.merge_cells(f'B{row}:D{row}')
        cell = self.ws.cell(row=row, column=2, value=title)
        cell.font = Font(size=11, bold=True)
        cell.fill = PatternFill(start_color='D9D9D9', end_color='D9D9D9', fill_type='solid')
        cell.border = Border(
            left=self.medium,
            right=self.medium,
            top=self.medium,
            bottom=self.medium
        )
    
    def add_space_to_section(self, section_index):
        """Add empty row to a section"""
        self.sections[section_index]['current_row'] += 1
    
    def add_timing_mark_to_section(self, section_index, start_time, end_time, label):
        """Add timing annotation to a section"""
        section = self.sections[section_index]
        self.ws = section['sheet']
        row = section['current_row']
        section['current_row'] += 1
        section['last_signal_row'] = row
        
        mid = (start_time + end_time) // 2
        cell = self.ws.cell(row=row, column=3+mid, value=label)
        cell.font = Font(size=9, italic=True, color='FF0000')
        cell.alignment = Alignment(horizontal='center')
        
        for i in range(start_time, end_time + 1):
            cell = self.ws.cell(row=row, column=3+i)
            if i == start_time:
                cell.border = Border(left=self.thin, top=self.thin)
            elif i == end_time:
                cell.border = Border(right=self.thin, top=self.thin)
            else:
                cell.border = Border(top=Side(style='thin', color='FF0000'))
    
    def finalize_section(self, section_index):
        """Add main border around a section"""
        section = self.sections[section_index]
        self.ws = section['sheet']
        
        start_row = 2
        end_row = section['last_signal_row']
        start_col = 2
        end_col = 52
        
        for row in range(start_row, end_row + 1):
            for col in range(start_col, end_col + 1):
                if row == start_row or row == end_row or col == start_col or col == end_col:
                    cell = self.ws.cell(row=row, column=col)
                    existing = cell.border
                    cell.border = Border(
                        left=self.thick if col == start_col else (existing.left if existing else None),
                        right=self.thick if col == end_col else (existing.right if existing else None),
                        top=self.thick if row == start_row else (existing.top if existing else None),
                        bottom=self.thick if row == end_row else (existing.bottom if existing else None)
                    )
        
        self.ws.sheet_view.showGridLines = False
    
    def save(self, filename="multi_section_timing.xlsx"):
        """Save the complete workbook"""
        # Finalize all sections
        for i in range(len(self.sections)):
            self.finalize_section(i)
        
        self.wb.save(filename)
        print(f"✓ Saved: {filename}")


def create_multi_section_diagram():
    """Create a timing diagram with multiple main sections"""
    
    diagram = MultiSectionTimingDiagram()
    
    # ==========================================================================
    # SECTION 1: MEASUREMENT
    # ==========================================================================
    measurement = diagram.create_section("MEASUREMENT")
    idx = 0  # Section index
    
    # Add subsections and signals
    diagram.add_subsection_to_section(idx, "POWER MANAGEMENT")
    diagram.add_signal_to_section(idx, "5Y5 State", 
        "OFF OFF OFF INIT INIT RUN RUN RUN RUN POWERLATCH POWERLATCH POSTRUN1 POSTRUN2 OFF OFF")
    diagram.add_signal_to_section(idx, "Battery", "00000111111111111111111111111111111111111000000")
    diagram.add_signal_to_section(idx, "Ignition", "00000001111111111111111111111111111111100000000")
    diagram.add_space_to_section(idx)
    
    diagram.add_subsection_to_section(idx, "COMMUNICATION")
    diagram.add_box_to_section(idx, "Sequence Mode", 5, 35, "Don't Care")
    diagram.add_box_to_section(idx, "CAN/LIN Wakeup", 8, 30)
    diagram.add_timing_mark_to_section(idx, 10, 15, "200 ms")
    diagram.add_space_to_section(idx)
    
    diagram.add_signal_to_section(idx, "CAN Active", "00000001111111111111111111111111111111100000000")
    diagram.add_signal_to_section(idx, "LIN Active", "00000000011111111111111111111111111111000000000")
    diagram.add_space_to_section(idx)
    
    diagram.add_subsection_to_section(idx, "CONTROL SIGNALS")
    diagram.add_signal_to_section(idx, "Brake", "00000000000011111100000000000000000000000000000")
    diagram.add_signal_to_section(idx, "Throttle", "00000000000000000011111111110000000000000000000")
    
    # ==========================================================================
    # SECTION 2: OPERATION
    # ==========================================================================
    operation = diagram.create_section("OPERATION")
    idx = 1  # Section index
    
    diagram.add_subsection_to_section(idx, "SYSTEM STATES")
    diagram.add_signal_to_section(idx, "ECU Mode", 
        "INACTIVE INACTIVE READY READY ACTIVE ACTIVE ACTIVE ACTIVE INACTIVE INACTIVE")
    diagram.add_signal_to_section(idx, "Charging State", 
        "OFF OFF OFF READY CHARGING CHARGING CHARGING READY OFF OFF")
    diagram.add_space_to_section(idx)
    
    diagram.add_subsection_to_section(idx, "MOTOR CONTROL")
    diagram.add_signal_to_section(idx, "Motor Enable", "00000001111111111111111111111111111111000000000")
    diagram.add_signal_to_section(idx, "Motor PWM", "00000000110011001100110011001100110011000000000")
    diagram.add_signal_to_section(idx, "Motor Direction", "00000001111111111111111100000000000000000000000")
    diagram.add_timing_mark_to_section(idx, 20, 30, "Ramp Up")
    diagram.add_space_to_section(idx)
    
    diagram.add_subsection_to_section(idx, "SAFETY MONITORS")
    diagram.add_signal_to_section(idx, "Temp Monitor", "00000000000000111111111111111111110000000000000")
    diagram.add_signal_to_section(idx, "Voltage Monitor", "11111111111111111111111111111111111111111111111")
    diagram.add_signal_to_section(idx, "Current Limit", "00000000000011111111111111111111100000000000000")
    
    # ==========================================================================
    # SECTION 3: DIAGNOSTICS
    # ==========================================================================
    diagnostics = diagram.create_section("DIAGNOSTICS")
    idx = 2  # Section index
    
    diagram.add_subsection_to_section(idx, "DIAGNOSTIC MODE")
    diagram.add_signal_to_section(idx, "Diag Mode", 
        "INACTIVE INACTIVE INACTIVE ACTIVE ACTIVE ACTIVE ACTIVE INACTIVE INACTIVE INACTIVE")
    diagram.add_signal_to_section(idx, "Test Request", "00000000001111111111111111111111100000000000000")
    diagram.add_signal_to_section(idx, "Test Response", "00000000000011111111111111111111000000000000000")
    diagram.add_space_to_section(idx)
    
    diagram.add_subsection_to_section(idx, "ERROR FLAGS")
    diagram.add_signal_to_section(idx, "Error Code", 
        "OFF OFF OFF OFF OFF ERROR ERROR ERROR OFF OFF OFF OFF OFF OFF OFF")
    diagram.add_signal_to_section(idx, "Warning Flag", "00000000000000001111111111000000000000000000000")
    diagram.add_signal_to_section(idx, "Fault Reset", "00000000000000000000000000000001000000000000000")
    diagram.add_timing_mark_to_section(idx, 15, 25, "Error Active")
    diagram.add_space_to_section(idx)
    
    diagram.add_subsection_to_section(idx, "MEMORY OPERATIONS")
    diagram.add_box_to_section(idx, "EEPROM Write", 10, 20, "Writing")
    diagram.add_box_to_section(idx, "EEPROM Read", 25, 35, "Reading")
    diagram.add_signal_to_section(idx, "Flash Update", "00000000001111111111100000000000000000000000000")
    
    # Save the complete diagram
    diagram.save("multi_section_timing.xlsx")
    
    return diagram


def create_custom_sections_from_input():
    """Create custom sections from user input"""
    
    diagram = MultiSectionTimingDiagram()
    
    # Define your sections here
    sections_config = [
        {
            'name': 'MEASUREMENT',
            'signals': [
                ('5Y5 State', 'OFF OFF INIT RUN RUN RUN POWERLATCH POSTRUN1 POSTRUN2 OFF'),
                ('Power', '00000111111111111111111111111111111111111000000'),
                ('CAN', '00000001111111111111111111111111111111100000000'),
            ]
        },
        {
            'name': 'OPERATION',
            'signals': [
                ('Motor', '00000001111111111111111111111111111111000000000'),
                ('Brake', '00000000000011111100000000000000000000000000000'),
                ('Status', 'IDLE IDLE INIT READY ACTIVE ACTIVE ACTIVE IDLE IDLE IDLE'),
            ]
        },
        {
            'name': 'TEST_MODE',
            'signals': [
                ('Test Enable', '00000000001111111111111111111111100000000000000'),
                ('Test Pattern', '01010101010101010101010101010101010101010101010'),
                ('Test Result', 'IDLE IDLE IDLE TEST TEST PASS PASS IDLE IDLE IDLE'),
            ]
        }
    ]
    
    # Create sections and add signals
    for idx, section_config in enumerate(sections_config):
        diagram.create_section(section_config['name'])
        
        for signal_name, pattern in section_config['signals']:
            diagram.add_signal_to_section(idx, signal_name, pattern)
        
        # Add timing mark to each section
        diagram.add_timing_mark_to_section(idx, 10, 20, f"Phase {idx+1}")
    
    diagram.save("custom_sections_timing.xlsx")
    print("✓ Created timing diagram with custom sections")


if __name__ == "__main__":
    print("\n" + "="*60)
    print("MULTI-SECTION ECU TIMING DIAGRAM GENERATOR")
    print("="*60)
    print("Creating timing diagrams with multiple main sections...")
    print("="*60)
    
    # Create multi-section diagram
    print("\n1. Creating multi-section timing diagram...")
    create_multi_section_diagram()
    print("   • MEASUREMENT section (Sheet 1)")
    print("   • OPERATION section (Sheet 2)")
    print("   • DIAGNOSTICS section (Sheet 3)")
    
    # Create custom sections
    print("\n2. Creating custom sections example...")
    create_custom_sections_from_input()
    print("   • MEASUREMENT section")
    print("   • OPERATION section")
    print("   • TEST_MODE section")
    
    print("\n" + "="*60)
    print("✓ COMPLETE! Generated files:")
    print("  • multi_section_timing.xlsx (3 sections on different sheets)")
    print("  • custom_sections_timing.xlsx (custom sections)")
    print("\nEach section has:")
    print("  • Its own bordered box with section name")
    print("  • Subsections for organization")
    print("  • Digital and state signals")
    print("  • Timing annotations")
    print("="*60)