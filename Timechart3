#!/usr/bin/env python3
"""
File-Based Multi-Section ECU Timing Diagram Generator
Create complex timing diagrams from simple text files
"""

import openpyxl
from openpyxl import Workbook
from openpyxl.styles import PatternFill, Border, Side, Alignment, Font
from openpyxl.utils import get_column_letter
import os

class FileBasedTimingGenerator:
    """File-based timing diagram generator"""
    
    def __init__(self):
        self.wb = Workbook()
        self.ws = None
        self.sections = []
        self.current_section_idx = -1
        
        # Border styles
        self.thin = Side(style='thin', color='000000')
        self.medium = Side(style='medium', color='000000')
        self.thick = Side(style='thick', color='000000')
        self.dotted = Side(style='dotted', color='808080')
        
        # State colors
        self.colors = {
            'OFF': 'FF6B6B',      # Red
            'INIT': 'FFD93D',     # Yellow  
            'RUN': '6BCF7F',      # Green
            'SLEEP': 'E8E8E8',    # Light gray
            'WAKE': 'FFE66D',     # Light yellow
            'POST1': '95E1D3',    # Light cyan
            'POST2': 'F38181',    # Light red
            'POSTRUN1': '95E1D3', # Light cyan
            'POSTRUN2': 'F38181', # Light red
            'LATCH': '4ECDC4',    # Cyan
            'POWERLATCH': '4ECDC4', # Cyan
            'ERROR': 'FF0000',    # Bright red
            'ACTIVE': '00FF00',   # Bright green
            'INACTIVE': 'C0C0C0', # Gray
            'READY': '90EE90',    # Light green
            'IDLE': 'F0E68C',     # Khaki
            'TEST': 'DDA0DD',     # Plum
            'PASS': '00FF00',     # Green
            'FAIL': 'FF0000',     # Red
        }
        
        self.time_units = 50
        
    def process_file(self, filename):
        """Process timing diagram file"""
        if not os.path.exists(filename):
            self.create_example_file(filename)
            print(f"âœ“ Created example file: {filename}")
            print("  Edit it and run again!")
            return False
        
        with open(filename, 'r') as f:
            lines = f.readlines()
        
        for line in lines:
            line = line.strip()
            if not line or line.startswith('#'):
                continue
            
            # Process commands
            if line.startswith('SECTION:'):
                self.start_new_section(line[8:].strip())
            elif line.startswith('SUBSECTION:'):
                self.add_subsection(line[11:].strip())
            elif line.startswith('SIGNAL:'):
                self.add_signal(line[7:].strip())
            elif line.startswith('BOX:'):
                self.add_box_signal(line[4:].strip())
            elif line.startswith('TIMING:'):
                self.add_timing(line[7:].strip())
            elif line.startswith('SPACE'):
                self.add_space()
            elif ':' in line and not line.startswith('//'):
                # Simple format: SignalName:Pattern
                parts = line.split(':', 1)
                self.add_signal(f"{parts[0].strip()}:{parts[1].strip()}")
        
        return True
    
    def start_new_section(self, section_info):
        """Start a new main section
        Format: SECTION:name[,sheet_name]"""
        parts = section_info.split(',')
        section_name = parts[0].strip()
        sheet_name = parts[1].strip() if len(parts) > 1 else section_name[:31]
        
        # Create new sheet or use existing
        if self.current_section_idx == -1:
            self.ws = self.wb.active
            self.ws.title = sheet_name
        else:
            self.ws = self.wb.create_sheet(sheet_name)
        
        self.current_section_idx += 1
        
        section = {
            'name': section_name,
            'sheet': self.ws,
            'current_row': 5,
            'first_signal_row': 5,
            'last_signal_row': 5
        }
        self.sections.append(section)
        
        # Setup section header
        self.ws.merge_cells('B2:AZ2')
        self.ws['B2'] = section_name.upper()
        self.ws['B2'].font = Font(size=12, bold=True)
        self.ws['B2'].alignment = Alignment(horizontal='center', vertical='center')
        
        # Column widths
        self.ws.column_dimensions['B'].width = 25
        for i in range(3, 53):
            self.ws.column_dimensions[get_column_letter(i)].width = 2.5
        
        # Time header
        for i in range(0, self.time_units, 5):
            cell = self.ws.cell(row=3, column=3+i, value=f"{i*20}ms")
            cell.font = Font(size=9, italic=True)
        
        # Grid lines
        for i in range(0, self.time_units):
            if i % 5 == 0:
                for row in range(4, 50):
                    cell = self.ws.cell(row=row, column=3+i)
                    cell.border = Border(left=self.dotted)
    
    def add_subsection(self, title):
        """Add subsection header"""
        if self.current_section_idx < 0:
            return
        
        section = self.sections[self.current_section_idx]
        row = section['current_row']
        section['current_row'] += 1
        
        self.ws.merge_cells(f'B{row}:D{row}')
        cell = self.ws.cell(row=row, column=2, value=title)
        cell.font = Font(size=11, bold=True)
        cell.fill = PatternFill(start_color='D9D9D9', end_color='D9D9D9', fill_type='solid')
        cell.border = Border(left=self.medium, right=self.medium, 
                           top=self.medium, bottom=self.medium)
    
    def add_signal(self, signal_info):
        """Add a signal
        Format: name:pattern"""
        if self.current_section_idx < 0:
            return
        
        parts = signal_info.split(':', 1)
        if len(parts) != 2:
            return
        
        name = parts[0].strip()
        pattern = parts[1].strip()
        
        section = self.sections[self.current_section_idx]
        row = section['current_row']
        section['current_row'] += 1
        section['last_signal_row'] = row
        
        # Add signal name
        self.ws.cell(row=row, column=2, value=name)
        self.ws.cell(row=row, column=2).font = Font(size=10, bold=True)
        
        # Handle pattern
        if ' ' in pattern:
            self._add_states(row, pattern.split())
        else:
            self._add_digital(row, pattern)
        
        self.ws.row_dimensions[row].height = 20
    
    def add_box_signal(self, box_info):
        """Add box signal
        Format: name:start:end[:label]"""
        if self.current_section_idx < 0:
            return
        
        parts = box_info.split(':')
        if len(parts) < 3:
            return
        
        name = parts[0].strip()
        start = int(parts[1].strip())
        end = int(parts[2].strip())
        label = parts[3].strip() if len(parts) > 3 else ""
        
        section = self.sections[self.current_section_idx]
        row = section['current_row']
        section['current_row'] += 1
        section['last_signal_row'] = row
        
        self.ws.cell(row=row, column=2, value=name)
        self.ws.cell(row=row, column=2).font = Font(size=10, bold=True)
        
        for i in range(start, end + 1):
            cell = self.ws.cell(row=row, column=3+i)
            cell.border = Border(
                left=self.thin if i == start else None,
                right=self.thin if i == end else None,
                top=self.thin,
                bottom=self.thin
            )
        
        if label:
            mid = (start + end) // 2
            cell = self.ws.cell(row=row, column=3+mid, value=label)
            cell.font = Font(size=9, italic=True)
            cell.alignment = Alignment(horizontal='center', vertical='center')
        
        self.ws.row_dimensions[row].height = 20
    
    def add_timing(self, timing_info):
        """Add timing mark
        Format: start:end:label"""
        if self.current_section_idx < 0:
            return
        
        parts = timing_info.split(':')
        if len(parts) != 3:
            return
        
        start = int(parts[0].strip())
        end = int(parts[1].strip())
        label = parts[2].strip()
        
        section = self.sections[self.current_section_idx]
        row = section['current_row']
        section['current_row'] += 1
        section['last_signal_row'] = row
        
        mid = (start + end) // 2
        cell = self.ws.cell(row=row, column=3+mid, value=label)
        cell.font = Font(size=9, italic=True, color='FF0000')
        cell.alignment = Alignment(horizontal='center')
        
        for i in range(start, end + 1):
            cell = self.ws.cell(row=row, column=3+i)
            if i == start:
                cell.border = Border(left=self.thin, top=self.thin)
            elif i == end:
                cell.border = Border(right=self.thin, top=self.thin)
            else:
                cell.border = Border(top=Side(style='thin', color='FF0000'))
    
    def add_space(self):
        """Add empty row"""
        if self.current_section_idx >= 0:
            self.sections[self.current_section_idx]['current_row'] += 1
    
    def _add_digital(self, row, pattern):
        """Add digital signal with borders"""
        prev_val = '0'
        
        for i, char in enumerate(pattern):
            if i >= self.time_units:
                break
            
            cell = self.ws.cell(row=row, column=3+i)
            
            if char in ['0', '1']:
                if i > 0:
                    prev_val = pattern[i-1] if i > 0 else '0'
                
                if prev_val != char:
                    if char == '1':
                        cell.border = Border(left=self.thin, top=self.thin)
                    else:
                        if i > 0:
                            prev_cell = self.ws.cell(row=row, column=3+i-1)
                            prev_border = prev_cell.border
                            prev_cell.border = Border(
                                left=prev_border.left,
                                right=self.thin,
                                top=prev_border.top,
                                bottom=prev_border.bottom
                            )
                        cell.border = Border(bottom=self.thin)
                elif char == '1':
                    cell.border = Border(top=self.thin)
                else:
                    cell.border = Border(bottom=self.thin)
            elif char == '-':
                cell.border = Border(top=self.dotted)
            elif char == 'X':
                cell.border = Border(left=self.dotted, right=self.dotted,
                                   top=self.dotted, bottom=self.dotted)
    
    def _add_states(self, row, states):
        """Add state signal"""
        current_state = states[0]
        start_col = 0
        
        for i, state in enumerate(states + ['END']):
            if state != current_state or i == len(states):
                end_col = i - 1
                
                if end_col >= start_col:
                    if end_col > start_col:
                        self.ws.merge_cells(
                            start_row=row, start_column=3+start_col,
                            end_row=row, end_column=3+end_col
                        )
                    
                    cell = self.ws.cell(row=row, column=3+start_col)
                    cell.value = current_state
                    cell.alignment = Alignment(horizontal='center', vertical='center')
                    cell.font = Font(size=9, bold=True)
                    
                    color = self.colors.get(current_state.upper(), 'FFFFFF')
                    cell.fill = PatternFill(start_color=color, end_color=color, fill_type='solid')
                    
                    for col in range(3+start_col, 3+end_col+1):
                        c = self.ws.cell(row=row, column=col)
                        c.border = Border(
                            left=self.thin if col == 3+start_col else None,
                            right=self.thin if col == 3+end_col else None,
                            top=self.thin,
                            bottom=self.thin
                        )
                
                current_state = state
                start_col = i
    
    def finalize(self):
        """Finalize all sections with borders"""
        for section in self.sections:
            self.ws = section['sheet']
            
            start_row = 2
            end_row = section['last_signal_row']
            start_col = 2
            end_col = 52
            
            for row in range(start_row, end_row + 1):
                for col in range(start_col, end_col + 1):
                    if row == start_row or row == end_row or col == start_col or col == end_col:
                        cell = self.ws.cell(row=row, column=col)
                        existing = cell.border
                        cell.border = Border(
                            left=self.thick if col == start_col else (existing.left if existing else None),
                            right=self.thick if col == end_col else (existing.right if existing else None),
                            top=self.thick if row == start_row else (existing.top if existing else None),
                            bottom=self.thick if row == end_row else (existing.bottom if existing else None)
                        )
            
            self.ws.sheet_view.showGridLines = False
    
    def save(self, filename):
        """Save the workbook"""
        self.finalize()
        self.wb.save(filename)
        print(f"âœ“ Saved: {filename}")
    
    def create_example_file(self, filename):
        """Create an example input file"""
        example_content = """# ECU Timing Diagram Configuration File
# =====================================
# Commands:
#   SECTION:name[,sheet_name]  - Start new main section
#   SUBSECTION:name            - Add subsection header
#   SIGNAL:name:pattern        - Add signal (digital or state)
#   BOX:name:start:end[:label] - Add box signal
#   TIMING:start:end:label     - Add timing annotation
#   SPACE                      - Add empty row
#   name:pattern               - Shorthand for SIGNAL:name:pattern
#
# Digital patterns: 0=low, 1=high, -=don't care, X=undefined
# State patterns: Space-separated state names (OFF INIT RUN SLEEP)

# ============================================================
# MEASUREMENT SECTION
# ============================================================
SECTION:MEASUREMENT

SUBSECTION:POWER MANAGEMENT
5Y5_State:OFF OFF OFF INIT INIT RUN RUN RUN RUN POWERLATCH POSTRUN1 POSTRUN2 OFF OFF
Battery:00000111111111111111111111111111111111111000000
Ignition:00000001111111111111111111111111111111100000000
SPACE

SUBSECTION:COMMUNICATION
BOX:Sequence_Mode:5:35:Don't Care
BOX:CAN_LIN_Wakeup:8:30
TIMING:10:15:200 ms
CAN_Active:00000001111111111111111111111111111111100000000
LIN_Active:00000000011111111111111111111111111111000000000
SPACE

SUBSECTION:CONTROL SIGNALS
Brake:00000000000011111100000000000000000000000000000
Throttle:00000000000000000011111111110000000000000000000
Clock:01010101010101010101010101010101010101010101010
SPACE

# ============================================================
# OPERATION SECTION (New Sheet)
# ============================================================
SECTION:OPERATION

SUBSECTION:SYSTEM STATES
ECU_Mode:IDLE IDLE READY READY ACTIVE ACTIVE ACTIVE ACTIVE IDLE IDLE
Charging:OFF OFF OFF READY ACTIVE ACTIVE ACTIVE READY OFF OFF
SPACE

SUBSECTION:MOTOR CONTROL
Motor_Enable:00000001111111111111111111111111111111000000000
Motor_PWM:00000000110011001100110011001100110011000000000
Motor_Direction:00000001111111111111111100000000000000000000000
TIMING:20:30:Ramp Up
SPACE

SUBSECTION:SAFETY MONITORS
Temp_Monitor:00000000000000111111111111111111110000000000000
Voltage_OK:11111111111111111111111111111111111111111111111
Current_Limit:00000000000011111111111111111111100000000000000

# ============================================================
# DIAGNOSTICS SECTION (New Sheet)
# ============================================================
SECTION:DIAGNOSTICS

SUBSECTION:DIAGNOSTIC MODE
Diag_Mode:INACTIVE INACTIVE INACTIVE ACTIVE ACTIVE ACTIVE ACTIVE INACTIVE INACTIVE
Test_Request:00000000001111111111111111111111100000000000000
Test_Response:00000000000011111111111111111111000000000000000
SPACE

SUBSECTION:ERROR FLAGS
Error_Code:OFF OFF OFF OFF OFF ERROR ERROR ERROR OFF OFF OFF OFF OFF
Warning_Flag:00000000000000001111111111000000000000000000000
Fault_Reset:00000000000000000000000000000001000000000000000
TIMING:15:25:Error Active
SPACE

SUBSECTION:MEMORY OPERATIONS
BOX:EEPROM_Write:10:20:Writing
BOX:EEPROM_Read:25:35:Reading
Flash_Update:00000000001111111111100000000000000000000000000

# ============================================================
# Add more sections as needed...
# For 200+ signals, organize them into logical sections
# ============================================================
"""
        with open(filename, 'w') as f:
            f.write(example_content)


def main():
    """Main function to create timing diagrams from files"""
    print("\n" + "="*70)
    print("FILE-BASED MULTI-SECTION TIMING DIAGRAM GENERATOR")
    print("="*70)
    
    # Default file names
    files = [
        ("timing_config.txt", "timing_output.xlsx"),
        ("custom_timing.txt", "custom_output.xlsx"),
        ("signals.txt", "signals_output.xlsx")
    ]
    
    for input_file, output_file in files:
        print(f"\nProcessing: {input_file}")
        print("-" * 40)
        
        generator = FileBasedTimingGenerator()
        if generator.process_file(input_file):
            generator.save(output_file)
            print(f"âœ“ Generated: {output_file}")
        else:
            print(f"  Please edit {input_file} and run again")
    
    print("\n" + "="*70)
    print("FILE FORMAT QUICK REFERENCE:")
    print("="*70)
    print("""
    SECTION:MEASUREMENT           # Start new section
    SUBSECTION:Power Management   # Add subsection header
    
    # Simple format:
    Power:00001111111100000      # Digital signal
    State:OFF INIT RUN SLEEP      # State signal
    
    # Box signals:
    BOX:CAN_Wake:10:30:Active    # Box from col 10-30 with label
    
    # Timing marks:
    TIMING:10:15:200ms           # Timing annotation
    
    SPACE                        # Empty row
    """)
    print("="*70)


if __name__ == "__main__":
    main()