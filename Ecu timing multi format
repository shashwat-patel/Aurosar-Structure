#!/usr/bin/env python3
"""
Multi-Format ECU Timing Diagram Generator
Outputs timing in multiple formats for automation testing:
- Excel visual diagram
- Text-based test vectors
- JSON for test automation
- CSV for test equipment
- C/C++ header files
- YAML test cases
- Python test scripts
"""

import json
import csv
import yaml
import openpyxl
from openpyxl import Workbook
from openpyxl.styles import PatternFill, Border, Side, Alignment, Font
from datetime import datetime
from pathlib import Path

class TimingSignal:
    """Represents a single timing signal with all its data"""
    
    def __init__(self, name, signal_type="digital", pattern=None, states=None, 
                 timing_ms=20, description=""):
        self.name = name
        self.signal_type = signal_type  # digital, state, analog, pwm
        self.pattern = pattern  # For digital: "0011001100"
        self.states = states    # For states: [(0, 5, "OFF"), (5, 10, "ON")]
        self.timing_ms = timing_ms  # Time per unit in milliseconds
        self.description = description
        self.transitions = []
        self._analyze_transitions()
    
    def _analyze_transitions(self):
        """Analyze signal for transitions (for test generation)"""
        if self.pattern and self.signal_type == "digital":
            prev = self.pattern[0]
            for i, val in enumerate(self.pattern):
                if val != prev:
                    self.transitions.append({
                        'time_ms': i * self.timing_ms,
                        'from': prev,
                        'to': val,
                        'edge': 'rising' if val == '1' else 'falling'
                    })
                    prev = val
        elif self.states:
            for start, end, state in self.states:
                self.transitions.append({
                    'time_ms': start * self.timing_ms,
                    'state': state,
                    'duration_ms': (end - start) * self.timing_ms
                })


class MultiFormatTimingDiagram:
    """Generate timing diagrams in multiple formats"""
    
    def __init__(self, title="ECU Timing Diagram", time_resolution_ms=20):
        self.title = title
        self.time_resolution_ms = time_resolution_ms
        self.signals = []
        self.sections = []
        self.timing_marks = []
        self.test_points = []
        
    def add_signal(self, signal):
        """Add a signal to the diagram"""
        self.signals.append(signal)
    
    def add_section(self, name):
        """Add a section divider"""
        self.sections.append(name)
    
    def add_timing_mark(self, start_ms, end_ms, label):
        """Add a timing annotation"""
        self.timing_marks.append({
            'start': start_ms,
            'end': end_ms,
            'label': label
        })
    
    def add_test_point(self, time_ms, signal_name, expected_value, description=""):
        """Add a test verification point"""
        self.test_points.append({
            'time_ms': time_ms,
            'signal': signal_name,
            'expected': expected_value,
            'description': description
        })
    
    # =========================================================================
    # FORMAT 1: Excel Visual Diagram
    # =========================================================================
    
    def export_excel(self, filename="timing_diagram.xlsx"):
        """Export as Excel visual diagram"""
        wb = Workbook()
        ws = wb.active
        ws.title = "Timing"
        
        # Setup styles
        thin = Side(style='thin', color='000000')
        thick = Side(style='thick', color='000000')
        
        # Title
        ws.merge_cells('B1:AZ1')
        ws['B1'] = self.title
        ws['B1'].font = Font(size=14, bold=True)
        ws['B1'].alignment = Alignment(horizontal='center')
        
        # Column widths
        ws.column_dimensions['B'].width = 25
        for i in range(3, 53):
            ws.column_dimensions[get_column_letter(i)].width = 2.5
        
        # Time header
        for i in range(0, 50, 5):
            ws.cell(row=2, column=3+i, value=f"{i*self.time_resolution_ms}ms")
            ws.cell(row=2, column=3+i).font = Font(size=9, italic=True)
        
        # Add signals
        row = 4
        for signal in self.signals:
            ws.cell(row=row, column=2, value=signal.name)
            ws.cell(row=row, column=2).font = Font(size=10, bold=True)
            
            if signal.pattern:
                # Digital signal with borders
                for i, val in enumerate(signal.pattern[:50]):
                    cell = ws.cell(row=row, column=3+i)
                    if i > 0 and signal.pattern[i-1] != val:
                        if val == '1':
                            cell.border = Border(left=thin, top=thin)
                        else:
                            prev_cell = ws.cell(row=row, column=3+i-1)
                            prev_cell.border = Border(right=thin, top=thin)
                    elif val == '1':
                        cell.border = Border(top=thin)
                    else:
                        cell.border = Border(bottom=thin)
            
            elif signal.states:
                # State signal with colored boxes
                for start, end, state in signal.states:
                    if start < 50:
                        ws.merge_cells(
                            start_row=row, start_column=3+start,
                            end_row=row, end_column=3+min(end-1, 49)
                        )
                        cell = ws.cell(row=row, column=3+start)
                        cell.value = state
                        cell.alignment = Alignment(horizontal='center', vertical='center')
                        cell.font = Font(size=9, bold=True)
                        
                        # Apply color based on state
                        colors = {
                            'OFF': 'FF6B6B', 'INIT': 'FFD93D', 'RUN': '6BCF7F',
                            'SLEEP': 'E8E8E8', 'ERROR': 'FF0000'
                        }
                        color = colors.get(state, 'FFFFFF')
                        cell.fill = PatternFill(start_color=color, end_color=color, fill_type='solid')
                        
                        # Add borders
                        for c in range(3+start, 3+min(end, 50)):
                            ws.cell(row=row, column=c).border = Border(
                                left=thin if c == 3+start else None,
                                right=thin if c == 3+min(end-1, 49) else None,
                                top=thin, bottom=thin
                            )
            row += 1
        
        wb.save(filename)
        print(f"✓ Excel diagram saved: {filename}")
    
    # =========================================================================
    # FORMAT 2: Text-Based Test Vectors
    # =========================================================================
    
    def export_test_vectors(self, filename="test_vectors.txt"):
        """Export as text-based test vectors for automation"""
        with open(filename, 'w') as f:
            f.write(f"# Test Vectors for: {self.title}\n")
            f.write(f"# Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
            f.write(f"# Time Resolution: {self.time_resolution_ms}ms per unit\n")
            f.write("#" + "="*70 + "\n\n")
            
            # Header with signal names
            f.write("# Time(ms) | ")
            for signal in self.signals:
                f.write(f"{signal.name:15} | ")
            f.write("\n")
            f.write("#" + "-"*70 + "\n")
            
            # Generate time-based vectors
            max_len = max(len(s.pattern) if s.pattern else 
                         max(e for _, e, _ in s.states) if s.states else 0 
                         for s in self.signals)
            
            for t in range(max_len):
                time_ms = t * self.time_resolution_ms
                f.write(f"{time_ms:8} | ")
                
                for signal in self.signals:
                    if signal.pattern and t < len(signal.pattern):
                        value = signal.pattern[t]
                    elif signal.states:
                        value = "UNDEF"
                        for start, end, state in signal.states:
                            if start <= t < end:
                                value = state
                                break
                    else:
                        value = "-"
                    f.write(f"{value:15} | ")
                f.write("\n")
            
            # Add test points
            if self.test_points:
                f.write("\n# TEST VERIFICATION POINTS\n")
                f.write("#" + "="*70 + "\n")
                for tp in self.test_points:
                    f.write(f"@{tp['time_ms']}ms: CHECK {tp['signal']} == {tp['expected']}")
                    if tp['description']:
                        f.write(f"  // {tp['description']}")
                    f.write("\n")
        
        print(f"✓ Test vectors saved: {filename}")
    
    # =========================================================================
    # FORMAT 3: JSON for Test Automation
    # =========================================================================
    
    def export_json(self, filename="timing_data.json"):
        """Export as JSON for test automation frameworks"""
        data = {
            'title': self.title,
            'generated': datetime.now().isoformat(),
            'time_resolution_ms': self.time_resolution_ms,
            'signals': [],
            'test_points': self.test_points,
            'timing_marks': self.timing_marks
        }
        
        for signal in self.signals:
            sig_data = {
                'name': signal.name,
                'type': signal.signal_type,
                'description': signal.description,
                'transitions': signal.transitions
            }
            
            if signal.pattern:
                sig_data['pattern'] = signal.pattern
                sig_data['values'] = [
                    {'time_ms': i * self.time_resolution_ms, 'value': val}
                    for i, val in enumerate(signal.pattern)
                ]
            
            if signal.states:
                sig_data['states'] = [
                    {
                        'start_ms': s * self.time_resolution_ms,
                        'end_ms': e * self.time_resolution_ms,
                        'state': state
                    }
                    for s, e, state in signal.states
                ]
            
            data['signals'].append(sig_data)
        
        with open(filename, 'w') as f:
            json.dump(data, f, indent=2)
        
        print(f"✓ JSON data saved: {filename}")
    
    # =========================================================================
    # FORMAT 4: CSV for Test Equipment
    # =========================================================================
    
    def export_csv(self, filename="timing_data.csv"):
        """Export as CSV for test equipment and data loggers"""
        with open(filename, 'w', newline='') as f:
            writer = csv.writer(f)
            
            # Header
            header = ['Time_ms'] + [s.name for s in self.signals]
            writer.writerow(header)
            
            # Data rows
            max_len = max(len(s.pattern) if s.pattern else 
                         max(e for _, e, _ in s.states) if s.states else 0 
                         for s in self.signals)
            
            for t in range(max_len):
                time_ms = t * self.time_resolution_ms
                row = [time_ms]
                
                for signal in self.signals:
                    if signal.pattern and t < len(signal.pattern):
                        value = signal.pattern[t]
                    elif signal.states:
                        value = ""
                        for start, end, state in signal.states:
                            if start <= t < end:
                                value = state
                                break
                    else:
                        value = ""
                    row.append(value)
                
                writer.writerow(row)
        
        print(f"✓ CSV data saved: {filename}")
    
    # =========================================================================
    # FORMAT 5: C/C++ Header for Embedded Testing
    # =========================================================================
    
    def export_c_header(self, filename="timing_test.h"):
        """Export as C header file for embedded system testing"""
        with open(filename, 'w') as f:
            guard = filename.upper().replace('.', '_').replace('-', '_')
            f.write(f"#ifndef {guard}\n")
            f.write(f"#define {guard}\n\n")
            f.write(f"/* Auto-generated timing test data */\n")
            f.write(f"/* {self.title} */\n")
            f.write(f"/* Generated: {datetime.now()} */\n\n")
            
            # Define states as enums
            all_states = set()
            for signal in self.signals:
                if signal.states:
                    for _, _, state in signal.states:
                        all_states.add(state)
            
            if all_states:
                f.write("/* System States */\n")
                f.write("typedef enum {\n")
                for i, state in enumerate(sorted(all_states)):
                    f.write(f"    STATE_{state.upper()} = {i},\n")
                f.write("    STATE_COUNT\n")
                f.write("} system_state_t;\n\n")
            
            # Define timing constants
            f.write("/* Timing Constants (ms) */\n")
            f.write(f"#define TIME_RESOLUTION_MS {self.time_resolution_ms}\n")
            for mark in self.timing_marks:
                label = mark['label'].replace(' ', '_').upper()
                f.write(f"#define TIMING_{label}_START_MS {mark['start']}\n")
                f.write(f"#define TIMING_{label}_END_MS {mark['end']}\n")
            f.write("\n")
            
            # Define test data structures
            f.write("/* Test Vector Structure */\n")
            f.write("typedef struct {\n")
            f.write("    uint32_t time_ms;\n")
            for signal in self.signals:
                if signal.signal_type == "digital":
                    f.write(f"    uint8_t {signal.name.lower().replace(' ', '_')};\n")
                elif signal.signal_type == "state":
                    f.write(f"    system_state_t {signal.name.lower().replace(' ', '_')}_state;\n")
            f.write("} test_vector_t;\n\n")
            
            # Generate test vectors
            f.write("/* Test Vectors */\n")
            f.write("const test_vector_t test_vectors[] = {\n")
            
            max_len = max(len(s.pattern) if s.pattern else 
                         max(e for _, e, _ in s.states) if s.states else 0 
                         for s in self.signals)
            
            for t in range(max_len):
                time_ms = t * self.time_resolution_ms
                f.write(f"    {{ .time_ms = {time_ms}")
                
                for signal in self.signals:
                    name = signal.name.lower().replace(' ', '_')
                    if signal.pattern and t < len(signal.pattern):
                        f.write(f", .{name} = {signal.pattern[t]}")
                    elif signal.states:
                        for start, end, state in signal.states:
                            if start <= t < end:
                                f.write(f", .{name}_state = STATE_{state.upper()}")
                                break
                
                f.write(" },\n")
            
            f.write("};\n\n")
            f.write(f"#define TEST_VECTOR_COUNT (sizeof(test_vectors)/sizeof(test_vector_t))\n\n")
            
            # Test points for verification
            if self.test_points:
                f.write("/* Test Verification Points */\n")
                f.write("typedef struct {\n")
                f.write("    uint32_t time_ms;\n")
                f.write("    const char* signal_name;\n")
                f.write("    const char* expected_value;\n")
                f.write("    const char* description;\n")
                f.write("} test_point_t;\n\n")
                
                f.write("const test_point_t test_points[] = {\n")
                for tp in self.test_points:
                    f.write(f'    {{ {tp["time_ms"]}, "{tp["signal"]}", ')
                    f.write(f'"{tp["expected"]}", "{tp.get("description", "")}" }},\n')
                f.write("};\n\n")
                f.write(f"#define TEST_POINT_COUNT (sizeof(test_points)/sizeof(test_point_t))\n\n")
            
            f.write(f"#endif /* {guard} */\n")
        
        print(f"✓ C header saved: {filename}")
    
    # =========================================================================
    # FORMAT 6: YAML Test Cases
    # =========================================================================
    
    def export_yaml(self, filename="test_cases.yaml"):
        """Export as YAML for test automation frameworks"""
        data = {
            'test_suite': {
                'name': self.title,
                'generated': datetime.now().isoformat(),
                'time_resolution_ms': self.time_resolution_ms,
                'test_cases': []
            }
        }
        
        # Generate test cases from transitions
        for signal in self.signals:
            if signal.transitions:
                test_case = {
                    'name': f"Test_{signal.name.replace(' ', '_')}",
                    'signal': signal.name,
                    'steps': []
                }
                
                for trans in signal.transitions:
                    if 'edge' in trans:
                        step = {
                            'time_ms': trans['time_ms'],
                            'action': f"check_{trans['edge']}_edge",
                            'from': trans['from'],
                            'to': trans['to']
                        }
                    else:
                        step = {
                            'time_ms': trans['time_ms'],
                            'action': 'check_state',
                            'expected': trans['state'],
                            'duration_ms': trans['duration_ms']
                        }
                    test_case['steps'].append(step)
                
                data['test_suite']['test_cases'].append(test_case)
        
        # Add verification test cases
        if self.test_points:
            verification_case = {
                'name': 'Verification_Points',
                'type': 'verification',
                'checks': self.test_points
            }
            data['test_suite']['test_cases'].append(verification_case)
        
        with open(filename, 'w') as f:
            yaml.dump(data, f, default_flow_style=False)
        
        print(f"✓ YAML test cases saved: {filename}")
    
    # =========================================================================
    # FORMAT 7: Python Test Script
    # =========================================================================
    
    def export_python_test(self, filename="test_timing.py"):
        """Export as Python unittest script"""
        with open(filename, 'w') as f:
            f.write('#!/usr/bin/env python3\n')
            f.write('"""Auto-generated timing tests"""\n\n')
            f.write('import unittest\n')
            f.write('import time\n\n')
            
            f.write('class TimingTest(unittest.TestCase):\n')
            f.write(f'    """Tests for {self.title}"""\n\n')
            
            f.write('    def setUp(self):\n')
            f.write('        self.timing_data = {\n')
            
            # Add signal data
            for signal in self.signals:
                f.write(f'            "{signal.name}": {{\n')
                if signal.pattern:
                    f.write(f'                "pattern": "{signal.pattern}",\n')
                if signal.states:
                    f.write(f'                "states": {signal.states},\n')
                if signal.transitions:
                    f.write(f'                "transitions": {signal.transitions}\n')
                f.write('            },\n')
            f.write('        }\n\n')
            
            # Generate test methods
            for signal in self.signals:
                method_name = f"test_{signal.name.lower().replace(' ', '_')}_transitions"
                f.write(f'    def {method_name}(self):\n')
                f.write(f'        """Test {signal.name} signal transitions"""\n')
                f.write(f'        signal_data = self.timing_data["{signal.name}"]\n')
                
                if signal.transitions:
                    f.write('        transitions = signal_data.get("transitions", [])\n')
                    f.write('        for trans in transitions:\n')
                    f.write('            time_ms = trans.get("time_ms", 0)\n')
                    f.write('            if "edge" in trans:\n')
                    f.write('                # Test digital transition\n')
                    f.write('                self.assertIn(trans["edge"], ["rising", "falling"])\n')
                    f.write('                print(f"At {time_ms}ms: {trans[\'edge\']} edge from {trans[\'from\']} to {trans[\'to\']}")\n')
                    f.write('            elif "state" in trans:\n')
                    f.write('                # Test state transition\n')
                    f.write('                print(f"At {time_ms}ms: State = {trans[\'state\']} for {trans[\'duration_ms\']}ms")\n')
                else:
                    f.write('        pass  # No transitions to test\n')
                f.write('\n')
            
            # Add test points verification
            if self.test_points:
                f.write('    def test_verification_points(self):\n')
                f.write('        """Test specific verification points"""\n')
                f.write('        test_points = [\n')
                for tp in self.test_points:
                    f.write(f'            {tp},\n')
                f.write('        ]\n')
                f.write('        for point in test_points:\n')
                f.write('            print(f"Verify at {point[\'time_ms\']}ms: {point[\'signal\']} == {point[\'expected\']}")\n')
                f.write('            # Add actual verification logic here\n')
                f.write('            self.assertIsNotNone(point["expected"])\n\n')
            
            f.write('if __name__ == "__main__":\n')
            f.write('    unittest.main()\n')
        
        print(f"✓ Python test script saved: {filename}")
    
    # =========================================================================
    # Export All Formats
    # =========================================================================
    
    def export_all(self, base_name="timing"):
        """Export in all available formats"""
        print("\n" + "="*60)
        print("Exporting timing diagram in all formats...")
        print("="*60)
        
        # Create output directory
        output_dir = Path(f"{base_name}_output")
        output_dir.mkdir(exist_ok=True)
        
        # Export all formats
        self.export_excel(output_dir / f"{base_name}.xlsx")
        self.export_test_vectors(output_dir / f"{base_name}_vectors.txt")
        self.export_json(output_dir / f"{base_name}_data.json")
        self.export_csv(output_dir / f"{base_name}_data.csv")
        self.export_c_header(output_dir / f"{base_name}_test.h")
        self.export_yaml(output_dir / f"{base_name}_tests.yaml")
        self.export_python_test(output_dir / f"test_{base_name}.py")
        
        print("\n" + "="*60)
        print(f"✓ All formats exported to: {output_dir}/")
        print("="*60)
        
        return output_dir


# =============================================================================
# Example Usage
# =============================================================================

def create_example_timing():
    """Create example timing diagram with all features"""
    
    # Create timing diagram
    timing = MultiFormatTimingDiagram("ECU Power Management Timing", time_resolution_ms=20)
    
    # Add signals
    timing.add_signal(TimingSignal(
        name="Battery_Power",
        signal_type="digital",
        pattern="00000111111111111111111111111111111111111000000000",
        description="Main battery power supply"
    ))
    
    timing.add_signal(TimingSignal(
        name="Ignition",
        signal_type="digital",
        pattern="00000001111111111111111111111111111111100000000",
        description="Ignition switch signal"
    ))
    
    timing.add_signal(TimingSignal(
        name="ECU_State",
        signal_type="state",
        states=[(0, 5, "OFF"), (5, 8, "INIT"), (8, 35, "RUN"), 
                (35, 40, "SHUTDOWN"), (40, 50, "OFF")],
        description="ECU operational state"
    ))
    
    timing.add_signal(TimingSignal(
        name="CAN_Bus",
        signal_type="digital",
        pattern="00000000111111111111111111111111111111000000000",
        description="CAN bus communication active"
    ))
    
    timing.add_signal(TimingSignal(
        name="Diagnostic_Mode",
        signal_type="state",
        states=[(0, 10, "INACTIVE"), (10, 30, "ACTIVE"), (30, 50, "INACTIVE")],
        description="Diagnostic mode status"
    ))
    
    # Add test points for automation
    timing.add_test_point(100, "ECU_State", "INIT", "ECU should be initializing")
    timing.add_test_point(200, "CAN_Bus", "1", "CAN should be active")
    timing.add_test_point(700, "ECU_State", "SHUTDOWN", "ECU entering shutdown")
    
    # Add timing marks
    timing.add_timing_mark(100, 160, "Boot Time: 60ms")
    timing.add_timing_mark(700, 800, "Shutdown: 100ms")
    
    return timing


def create_from_simple_input(input_text):
    """Create timing from simple text format"""
    timing = MultiFormatTimingDiagram("Custom Timing Diagram")
    
    lines = input_text.strip().split('\n')
    for line in lines:
        if ':' in line:
            name, pattern = line.split(':', 1)
            name = name.strip()
            pattern = pattern.strip()
            
            if ' ' in pattern:
                # State signal
                states = []
                state_list = pattern.split()
                current_state = state_list[0]
                start = 0
                
                for i, state in enumerate(state_list + ['END']):
                    if state != current_state or i == len(state_list):
                        states.append((start, i, current_state))
                        current_state = state
                        start = i
                
                timing.add_signal(TimingSignal(
                    name=name,
                    signal_type="state",
                    states=states
                ))
            else:
                # Digital signal
                timing.add_signal(TimingSignal(
                    name=name,
                    signal_type="digital",
                    pattern=pattern
                ))
    
    return timing


if __name__ == "__main__":
    print("\n" + "="*80)
    print("MULTI-FORMAT ECU TIMING DIAGRAM GENERATOR")
    print("="*80)
    
    # Create example timing
    print("\n1. Creating example timing diagram...")
    timing = create_example_timing()
    
    # Export in all formats
    output_dir = timing.export_all("ecu_timing")
    
    # Show what was created
    print("\n" + "="*80)
    print("GENERATED FILES FOR AUTOMATION TESTING:")
    print("="*80)
    
    print("\n📊 VISUAL FORMATS:")
    print("  • ecu_timing.xlsx         - Excel visual diagram")
    
    print("\n📝 TEST AUTOMATION FORMATS:")
    print("  • ecu_timing_vectors.txt  - Text-based test vectors")
    print("  • ecu_timing_data.json    - JSON for automation frameworks")
    print("  • ecu_timing_data.csv     - CSV for test equipment")
    print("  • ecu_timing_test.h       - C header for embedded testing")
    print("  • ecu_timing_tests.yaml   - YAML test case definitions")
    print("  • test_ecu_timing.py      - Python unittest script")
    
    print("\n💡 USAGE EXAMPLES:")
    print("\n1. For automation testing with Python:")
    print("   python test_ecu_timing.py")
    
    print("\n2. For embedded C testing:")
    print("   #include \"ecu_timing_test.h\"")
    print("   // Use test_vectors[] array for verification")
    
    print("\n3. For test equipment:")
    print("   Load ecu_timing_data.csv into your test tool")
    
    print("\n4. For CI/CD pipelines:")
    print("   Use ecu_timing_tests.yaml with your test framework")
    
    print("\n" + "="*80)
    
    # Create custom timing from simple input
    print("\n2. Creating custom timing from simple format...")
    
    simple_input = """
    Power:00000111111111111111111111111111111111111000000000
    Ignition:00000001111111111111111111111111111111100000000
    ECU_State:OFF OFF OFF INIT INIT RUN RUN RUN RUN RUN SHUTDOWN OFF
    CAN_Active:00000000111111111111111111111111111111000000000
    """
    
    custom_timing = create_from_simple_input(simple_input)
    custom_timing.export_all("custom_timing")
    
    print("\n✓ Custom timing also exported in all formats!")
    print("="*80)